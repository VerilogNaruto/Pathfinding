!function(g){function I(e){if(n[e])return n[e].exports;var l=n[e]={i:e,l:!1,exports:{}};return g[e].call(l.exports,l,l.exports,I),l.l=!0,l.exports}var n={};I.m=g,I.c=n,I.i=function(g){return g},I.d=function(g,n,e){I.o(g,n)||Object.defineProperty(g,n,{configurable:!1,enumerable:!0,get:e})},I.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(n,"a",n),n},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="",I(I.s=4)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _Maze = __webpack_require__(2);\n\nvar _Maze2 = _interopRequireDefault(_Maze);\n\nvar _Cell = __webpack_require__(1);\n\nvar _Cell2 = _interopRequireDefault(_Cell);\n\nvar _Search = __webpack_require__(3);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Board(height, width) {\n  this.height = height;\n  this.width = width;\n  this.boardArr = [];\n  this.mouseDown = false;\n  this.keyDown = false;\n  this.startNode;\n  this.finalNode;\n  this.objectNode;\n  this.currentCellStatus = null;\n  this.mode = 0;\n  this.currentPlace = null;\n  this.shouldBe = null;\n  this.algoDone = false;\n  this.currentAlgo = null;\n  this.lastWall = false;\n  this.lastWeight = false;\n  this.algoToRun = null;\n  this.canPress = true;\n  this.shouldDisable = false;\n  this.modalIndex = 0;\n  this.modalArr = [];\n} /**\n   * JavaScript Program By SOULEYMANE DEMBELE 09/23/2019\n   */\n\nBoard.prototype.initialise = function () {\n  this.createGrid();\n  this.addEventListeners();\n};\n\nBoard.prototype.createGrid = function () {\n  var initialHTML = '';\n  for (var i = 0; i < this.height; i++) {\n    //Add row HTML\n    initialHTML += \"<tr id='row\" + i.toString() + \"'>\";\n    //Add row boardArr \n    this.boardArr.push([]);\n    for (var j = 0; j < this.width; j++) {\n      //Add individual table Elements HTML \n      initialHTML += \"<td id='\" + j.toString() + \",\" + i.toString() + \"' class='unexplored'>\" + \"</td>\";\n      //Add cell element to boardArr\n      var newCell = new _Cell2.default(j, i);\n      this.boardArr[this.boardArr.length - 1].push(newCell);\n    }\n    //Finish row element HTML\n    initialHTML += \"</tr>\";\n  }\n  var board = document.getElementById('board');\n  board.innerHTML = initialHTML;\n  //Set Initial start Node\n  var xStartNode = Math.floor(this.boardArr.length / 4);\n  var y = Math.floor(this.boardArr.length / 2);\n  this.boardArr[y][xStartNode].status = 'startNode';\n  this.startNode = this.boardArr[y][xStartNode];\n  document.getElementById(this.startNode.id).className = 'startingCell';\n  //Set Initial end Node\n  var xFinalNode = Math.floor(3 * this.boardArr[0].length / 4);\n  this.finalNode = this.boardArr[y][xFinalNode];\n  this.boardArr[y][xFinalNode].status = 'finalNode';\n  document.getElementById(this.finalNode.id).className = 'finalCell';\n};\n\nBoard.prototype.addEventListeners = function () {\n  $(\"#instructions_panel\").draggable();\n  // $(\"#instructions_panel\").css({ top: '200px' });\n  var board = this;\n  //Add window keyDown event \n  window.addEventListener('keydown', function (e) {\n    e.keyCode === 16 || e.keyCode === 87 ? board.keyDown = e.keyCode : board.keyDown;\n  });\n  //Add window keyUp event \n  window.addEventListener('keyup', function () {\n    board.keyDown = false;\n  });\n  //Create Modal\n  // board.createModal()\n  //Add listeners for table elements  \n  for (var i = 0; i < this.height; i++) {\n    for (var j = 0; j < this.width; j++) {\n      var id = j.toString() + ',' + i.toString();\n      var elem = document.getElementById(id);\n      elem.addEventListener('mousedown', function (e) {\n        e.preventDefault();\n        if (this.className !== 'startingCell' && this.className !== 'startingCell shortestPath' && this.className !== 'finalCell' && this.className !== 'finalCellUP' && this.className !== 'finalCellRIGHT' && this.className !== 'finalCellDOWN' && this.className !== 'finalCellLEFT' && this.className !== 'objectCell' && !board.shouldDisable) {\n          board.changeCellClick(this.id);\n          board.mouseDown = true;\n        } else {\n          board.currentCellStatus = this.className;\n          board.mouseDown = true;\n        }\n      });\n      elem.addEventListener('mouseup', function (e) {\n        e.preventDefault();\n        board.mouseDown = false;\n        board.currentCellStatus = null;\n      });\n      elem.addEventListener('mouseenter', function (e) {\n        //  console.log(this.className)\n        e.preventDefault();\n        //Normal Wall Creation Drag Event\n        if (board.mouseDown && board.currentCellStatus === null && !board.shouldDisable) {\n          board.changeCellDrag(this.id);\n        }\n        //Dragging a start/end node \n        else if (board.mouseDown && board.currentCellStatus !== null && this.className !== 'startingCell' && this.className !== 'startingCell shortestPath' && this.className !== 'finalCell' && this.className !== 'finalCellUP' && this.className !== 'finalCellRIGHT' && this.className !== 'finalCellDOWN' && this.className !== 'finalCellLEFT' && !board.shouldDisable) {\n            this.className = board.currentCellStatus;\n            var idSplit = this.id.split(',');\n            var cell = board.getCell(idSplit[0], idSplit[1]);\n            if (this.className === 'startingCell' || this.className === 'startingCell shortestPath') {\n              if (cell.status === 'wall') {\n                board.lastWall = true;\n              } else if (cell.status === 'unexplored weight') {\n                board.lastWeight = true;\n              }\n              cell.status = 'startNode';\n              board.startNode = cell;\n              if (board.algoDone) {\n                board.clearPath();\n                var search = new _Search2.default(board.boardArr, board.startNode, board.finalNode, board.currentAlgo, board);\n                search.startSearch();\n              }\n            } else if (this.className === 'finalCell' || this.className === 'finalCellUP' || this.className === 'finalCellRIGHT' || this.className === 'finalCellDOWN' || this.className === 'finalCellLEFT') {\n              if (cell.status === 'wall') {\n                board.lastWall = true;\n              } else if (cell.status === 'unexplored weight') {\n                board.lastWeight = true;\n              }\n              cell.status = 'finalNode';\n              board.finalNode = cell;\n              if (board.algoDone) {\n                board.clearPath();\n                var search = new _Search2.default(board.boardArr, board.startNode, board.finalNode, board.currentAlgo, board);\n                search.startSearch();\n              }\n            }\n          } else if (board.mouseDown && board.currentCellStatus !== null && (this.className === 'startingCell' || this.className === 'startingCell shortestPath' || this.className === 'finalCell' || this.className === 'finalCellUP' || this.className === 'finalCellRIGHT' || this.className === 'finalCellDOWN' || this.className === 'finalCellLEFT') && !board.shouldDisable) {\n            if (this.className === 'startingCell' || this.className === 'startingCell shortestPath') {\n              board.shouldBe = 'startingCell';\n            } else if (this.className === 'finalCell' || this.className === 'finalCellUP' || this.className === 'finalCellRIGHT' || this.className === 'finalCellDOWN' || this.className === 'finalCellLEFT') {\n              board.shouldBe = 'finalCell';\n            } else if (this.className === 'objectCell') {\n              board.shouldBe = 'objectCell';\n            }\n          }\n      });\n      elem.addEventListener('mouseout', function (e) {\n        e.preventDefault();\n        if ((this.className === 'startingCell' || this.className === 'startingCell shortestPath' || this.className === 'finalCell' || this.className === 'finalCellUP' || this.className === 'finalCellRIGHT' || this.className === 'finalCellDOWN' || this.className === 'finalCellLEFT') && !board.shouldDisable) {\n          if (board.mouseDown && board.currentCellStatus !== null) {\n            if (board.shouldBe) {\n              this.className = board.shouldBe;\n              board.shouldBe = null;\n            } else {\n              if (board.lastWall) {\n                board.clearPath();\n                var idSplit = this.id.split(',');\n                var cell = board.getCell(idSplit[0], idSplit[1]);\n                this.className = 'wall';\n                cell.status = 'wall';\n                board.lastWall = false;\n              } else if (board.lastWeight) {\n                board.clearPath();\n                var idSplit = this.id.split(',');\n                var cell = board.getCell(idSplit[0], idSplit[1]);\n                this.className = 'unexplored weight';\n                cell.status = 'unexplored weight';\n                cell.weight = 15;\n                board.lastWeight = false;\n              } else {\n                board.clearPath();\n                var idSplit = this.id.split(',');\n                var cell = board.getCell(idSplit[0], idSplit[1]);\n                this.className = 'unexplored';\n                cell.status = 'unexplored';\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n  //Add Listeners for Button Panel\n  //BFS\n  document.getElementById('startButtonBFS').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      document.getElementById('visualise').innerHTML = 'Visualise BFS';\n      board.algoToRun = 'BFS';\n      // search.startSearch()\n    }\n  });\n  //DFS\n  document.getElementById('startButtonDFS').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      document.getElementById('visualise').innerHTML = 'Visualise DFS';\n      board.algoToRun = 'DFS';\n      // search.startSearch()\n    }\n  });\n  //Dijkstra \n  document.getElementById('startButtonDijkstra').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      document.getElementById('visualise').innerHTML = 'Visualise Dijkstra';\n      board.algoToRun = 'Dijkstra';\n      // search.startSearch()\n    }\n  });\n  //Fake AStar 1\n  // document.getElementById('startButtonAStar').addEventListener('click',function(){ \n  //   if(!board.shouldDisable){\n  //     document.getElementById('visualise').innerHTML = 'Visualise Swarm'\n  //     board.algoToRun = 'AStar'\n  //     // search.startSearch()\n  //   }\n  // })\n  // //Fake AStar 2\n  // document.getElementById('startButtonAStar2').addEventListener('click',function(){  \n  //   if(!board.shouldDisable){\n  //     document.getElementById('visualise').innerHTML = 'Visualise Convergent Swarm'\n  //     board.algoToRun = 'AStar2'\n  //     // search.startSearch()\n  //   }\n  // })\n  // //Greedy\n  // document.getElementById('startButtonGreedy').addEventListener('click',function(){ \n  //    if(!board.shouldDisable){ \n  //     document.getElementById('visualise').innerHTML = 'Visualise Best First Search'\n  //     board.algoToRun = 'Greedy'\n  //     // search.startSearch()\n  //    }\n  // })\n\n  document.getElementById('startButtonRealAStar').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      document.getElementById('visualise').innerHTML = \"Visualise A*\";\n      board.algoToRun = 'RealAStar';\n    }\n  });\n  document.getElementById('startButtonBasicMaze').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      var maze = new _Maze2.default(board, board.startNode, board.finalNode, 'basicMaze');\n      maze.startMaze();\n    }\n  });\n  //Recursive Division 1\n  document.getElementById('startButtonBossMaze1').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      var maze = new _Maze2.default(board, board.startNode, board.finalNode, 'bossMaze1', true);\n      maze.startMaze();\n    }\n  });\n  //Recursive Division 2\n  document.getElementById('startButtonBossMaze2').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      var maze = new _Maze2.default(board, board.startNode, board.finalNode, 'bossMaze2', true);\n      maze.startMaze();\n    }\n  });\n  //Recursive Division 3\n  document.getElementById('startButtonBossMaze3').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      var maze = new _Maze2.default(board, board.startNode, board.finalNode, 'bossMaze3', true);\n      maze.startMaze();\n    }\n  });\n  //Basic Weight Maze \n  document.getElementById('startButtonBasicWeightMaze').addEventListener('click', function () {\n    console.log(board.shouldDisable);\n    if (!board.shouldDisable) {\n      var maze = new _Maze2.default(board, board.startNode, board.finalNode, 'basicWeightMaze', false);\n      maze.startMaze();\n    }\n  });\n  //Pokemon Theme\n  // document.getElementById('startButtonPokemonTheme').addEventListener('click',function(){\n  //   //\n  // }) \n  //Visualise Algorithm\n  document.getElementById('startButtonVisualise').addEventListener('click', function () {\n    board.algoDone = false;\n    // console.log(board.shouldDisable)\n    if (!board.shouldDisable && board.algoToRun) {\n      board.clearPath();\n      var algoName = board.algoToRun;\n      var search = new _Search2.default(board.boardArr, board.startNode, board.finalNode, algoName, board);\n      search.startSearch();\n    }\n  });\n  //Path\n  document.getElementById('path').addEventListener('click', function () {\n    location.reload();\n  });\n  //Clear Path\n  document.getElementById('startButtonClearPath').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      board.algoDone = false;\n      board.clearPath();\n    }\n  });\n  //Clear Walls\n  document.getElementById('startButtonClearWalls').addEventListener('click', function () {\n    if (!board.shouldDisable) {\n      board.clearWalls();\n    }\n  });\n  //Modal Buttons \n  // //Increment Page\n  // document.getElementById('nextButton').addEventListener('click',function(){\n  //   board.incrementModal()\n  // })\n  // //Decrement Page \n  // document.getElementById('previousButton').addEventListener('click',function(){\n  //   board.decrementModal()\n  // }) \n  //Close instructions \n  // document.getElementById('x').addEventListener('click',function(){\n  //    document.getElementById('panelParent').innerHTML = ''\n  //   //  console.log(\"ASF\")\n  //   //  board.changeToRed()\n  // })\n};\n\nBoard.prototype.getCell = function (x, y) {\n  return this.boardArr[y][x];\n};\n\nBoard.prototype.changeCellClick = function (id) {\n  var newId = id.split(',');\n  var x = parseInt(newId[0]);\n  var y = parseInt(newId[1]);\n  var cell = this.getCell(x, y);\n  var toggledCell = this.toggle(cell);\n  var elem = document.getElementById(id);\n  if (toggledCell) {\n    elem.className = toggledCell;\n  }\n};\n\nBoard.prototype.changeCellDrag = function (id) {\n  var newId = id.split(',');\n  var x = parseInt(newId[0]);\n  var y = parseInt(newId[1]);\n  var cell = this.getCell(x, y);\n  if (cell.status !== 'finalCell' && cell.status !== 'startingCell') {\n    var toggledCell = this.toggle(cell);\n    var elem = document.getElementById(id);\n    if (toggledCell) {\n      elem.className = toggledCell;\n    }\n  }\n};\n\nBoard.prototype.toggle = function (cell) {\n  if (cell.status === 'unexplored' && this.keyDown || cell.status === 'explored' && this.keyDown || cell.status === 'wall' && this.keyDown) {\n    // cell.status = 'unexplored water'\n    if (this.keyDown === 87) {\n      cell.weight = 15;\n      cell.status = 'unexplored weight';\n      return cell.status;\n    }\n  } else if (cell.status === 'unexplored' || cell.status === 'explored') {\n    cell.status = 'wall';\n    return cell.status;\n  } else if (cell.status === 'explored weight' || cell.status === 'unexplored weight') {\n    cell.status = 'unexplored';\n    cell.weight = 0;\n    return cell.status;\n  } else if (cell.status === 'wall') {\n    cell.status = 'unexplored';\n    return cell.status;\n  } else {\n    return false;\n  }\n};\n\nBoard.prototype.createModal = function () {\n  // Get the modal\n  var modal = document.getElementById('myModal');\n  modal.style.display = \"block\";\n  modal.height = \"500px\";\n  document.getElementById('innerDisplay').innerHTML = this.modalArr[this.modalIndex];\n\n  // Get the <span> element that closes the modal\n  var span = document.getElementsByClassName(\"close\")[0];\n\n  // When the user clicks on <span> (x), close the modal\n  span.onclick = function () {\n    modal.style.display = \"none\";\n  };\n\n  // When the user clicks anywhere outside of the modal, close it\n  // window.onclick = function(event) {\n  //     if (event.target == modal) {\n  //         modal.style.display = \"none\";\n  //     }\n  // }\n};\n\nBoard.prototype.incrementModal = function () {\n  console.log('JQUERY', $(\"#myModal\"));\n  if (this.modalIndex < this.modalArr.length - 1) {\n    this.modalIndex += 1;\n    document.getElementById('innerDisplay').innerHTML = this.modalArr[this.modalIndex];\n  } else if (this.modalIndex === this.modalArr.length - 1) {\n    var modal = document.getElementById('myModal');\n    modal.style.display = \"none\";\n  }\n};\n\nBoard.prototype.decrementModal = function () {\n  if (this.modalIndex > 0) {\n    this.modalIndex -= 1;\n    document.getElementById('innerDisplay').innerHTML = this.modalArr[this.modalIndex];\n  }\n};\n\nBoard.prototype.changeToRed = function () {\n  var list = document.getElementsByClassName('toggleColour');\n  document.getElementById('visualise').style.color = 'red';\n  for (var i = 0; i < list.length; i++) {\n    list[i].style.color = 'red';\n  }\n};\n\nBoard.prototype.changeFromRed = function () {\n  var list = document.getElementsByClassName('toggleColour');\n  document.getElementById('visualise').style.color = 'e1e4e7';\n  for (var i = 0; i < list.length; i++) {\n    list[i].style.color = 'e1e4e7';\n  }\n};\n\nBoard.prototype.clearPath = function () {\n  document.getElementById(this.finalNode.id).className = 'finalCell';\n  document.getElementById(this.startNode.id).className = 'startingCell';\n  // console.log('in clear path')\n  for (var i = 0; i < this.boardArr.length; i++) {\n    for (var j = 0; j < this.boardArr[i].length; j++) {\n      var cell = this.boardArr[i][j];\n      cell.parent = null;\n      if (cell.status === 'explored' || cell.status === 'shortestPath') {\n        cell.status = 'unexplored';\n        document.getElementById(cell.id).className = 'unexplored';\n      } else if (cell.status === 'shortestPath explored weight' || cell.status === 'explored weight') {\n        cell.status = 'unexplored weight';\n        document.getElementById(cell.id).className = 'unexplored weight';\n      }\n      if (cell.status !== 'startNode') {\n        cell.direction = 'UP';\n        cell.distance = Infinity;\n      }\n    }\n  }\n};\n\nBoard.prototype.clearParents = function (show) {\n  console.log(\"clear Parents\");\n  for (var i = 0; i < this.boardArr.length; i++) {\n    for (var j = 0; j < this.boardArr[i].length; j++) {\n      var cell = this.boardArr[i][j];\n      if (!show && cell.status !== 'shortestPath' && cell.status !== 'objectNode' && cell.status !== 'startNode') {\n        cell.parent = null;\n        cell.direction = 'UP';\n        cell.distance = Infinity;\n      }\n      if (show) {\n        console.log(cell);\n      }\n    }\n  }\n};\n\nBoard.prototype.clearWalls = function () {\n  for (var i = 0; i < this.boardArr.length; i++) {\n    for (var j = 0; j < this.boardArr[i].length; j++) {\n      var cell = this.boardArr[i][j];\n      cell.parent = null;\n      // console.log(j,i,cell)\n      if (cell.status === 'wall' || cell.status === 'unexplored weight') {\n        cell.status = 'unexplored';\n        cell.weight = 0;\n        document.getElementById(cell.id).className = 'unexplored';\n      }\n    }\n  }\n};\n\nBoard.prototype.generateRandom = function () {\n  console.log(\"Generating random Maze\");\n};\n\nvar bar = document.getElementById('navbarDiv').clientHeight + document.getElementById('mainText').clientHeight;\nvar height = Math.floor(document.documentElement.clientHeight) - bar;\nvar width = Math.floor(document.documentElement.clientWidth);\nvar finalHeight = height / 27;\nvar finalWidth = width / 25;\n$(\"#instructions_panel\").css({ top: finalHeight * 27 / 4 + 'px' });\n$(\"#instructions_panel\").css({ left: finalWidth * 25 / 3.5 + 'px' });\nvar board = new Board(finalHeight, finalWidth - 1);\n// var board = new Board(10,10)\nboard.initialise();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9pbmRleC5qcz9hNjU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9NYXplID0gcmVxdWlyZSgnLi9NYXplJyk7XG5cbnZhciBfTWF6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NYXplKTtcblxudmFyIF9DZWxsID0gcmVxdWlyZSgnLi9DZWxsJyk7XG5cbnZhciBfQ2VsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DZWxsKTtcblxudmFyIF9TZWFyY2ggPSByZXF1aXJlKCcuL1NlYXJjaCcpO1xuXG52YXIgX1NlYXJjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZWFyY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBCb2FyZChoZWlnaHQsIHdpZHRoKSB7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuYm9hcmRBcnIgPSBbXTtcbiAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgdGhpcy5rZXlEb3duID0gZmFsc2U7XG4gIHRoaXMuc3RhcnROb2RlO1xuICB0aGlzLmZpbmFsTm9kZTtcbiAgdGhpcy5vYmplY3ROb2RlO1xuICB0aGlzLmN1cnJlbnRDZWxsU3RhdHVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gMDtcbiAgdGhpcy5jdXJyZW50UGxhY2UgPSBudWxsO1xuICB0aGlzLnNob3VsZEJlID0gbnVsbDtcbiAgdGhpcy5hbGdvRG9uZSA9IGZhbHNlO1xuICB0aGlzLmN1cnJlbnRBbGdvID0gbnVsbDtcbiAgdGhpcy5sYXN0V2FsbCA9IGZhbHNlO1xuICB0aGlzLmxhc3RXZWlnaHQgPSBmYWxzZTtcbiAgdGhpcy5hbGdvVG9SdW4gPSBudWxsO1xuICB0aGlzLmNhblByZXNzID0gdHJ1ZTtcbiAgdGhpcy5zaG91bGREaXNhYmxlID0gZmFsc2U7XG4gIHRoaXMubW9kYWxJbmRleCA9IDA7XG4gIHRoaXMubW9kYWxBcnIgPSBbXTtcbn0gLyoqXG4gICAqIEphdmFTY3JpcHQgUHJvZ3JhbSBCeSBTT1VMRVlNQU5FIERFTUJFTEUgMDkvMjMvMjAxOVxuICAgKi9cblxuQm9hcmQucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY3JlYXRlR3JpZCgpO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG5Cb2FyZC5wcm90b3R5cGUuY3JlYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGluaXRpYWxIVE1MID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oZWlnaHQ7IGkrKykge1xuICAgIC8vQWRkIHJvdyBIVE1MXG4gICAgaW5pdGlhbEhUTUwgKz0gXCI8dHIgaWQ9J3Jvd1wiICsgaS50b1N0cmluZygpICsgXCInPlwiO1xuICAgIC8vQWRkIHJvdyBib2FyZEFyciBcbiAgICB0aGlzLmJvYXJkQXJyLnB1c2goW10pO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy53aWR0aDsgaisrKSB7XG4gICAgICAvL0FkZCBpbmRpdmlkdWFsIHRhYmxlIEVsZW1lbnRzIEhUTUwgXG4gICAgICBpbml0aWFsSFRNTCArPSBcIjx0ZCBpZD0nXCIgKyBqLnRvU3RyaW5nKCkgKyBcIixcIiArIGkudG9TdHJpbmcoKSArIFwiJyBjbGFzcz0ndW5leHBsb3JlZCc+XCIgKyBcIjwvdGQ+XCI7XG4gICAgICAvL0FkZCBjZWxsIGVsZW1lbnQgdG8gYm9hcmRBcnJcbiAgICAgIHZhciBuZXdDZWxsID0gbmV3IF9DZWxsMi5kZWZhdWx0KGosIGkpO1xuICAgICAgdGhpcy5ib2FyZEFyclt0aGlzLmJvYXJkQXJyLmxlbmd0aCAtIDFdLnB1c2gobmV3Q2VsbCk7XG4gICAgfVxuICAgIC8vRmluaXNoIHJvdyBlbGVtZW50IEhUTUxcbiAgICBpbml0aWFsSFRNTCArPSBcIjwvdHI+XCI7XG4gIH1cbiAgdmFyIGJvYXJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JvYXJkJyk7XG4gIGJvYXJkLmlubmVySFRNTCA9IGluaXRpYWxIVE1MO1xuICAvL1NldCBJbml0aWFsIHN0YXJ0IE5vZGVcbiAgdmFyIHhTdGFydE5vZGUgPSBNYXRoLmZsb29yKHRoaXMuYm9hcmRBcnIubGVuZ3RoIC8gNCk7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih0aGlzLmJvYXJkQXJyLmxlbmd0aCAvIDIpO1xuICB0aGlzLmJvYXJkQXJyW3ldW3hTdGFydE5vZGVdLnN0YXR1cyA9ICdzdGFydE5vZGUnO1xuICB0aGlzLnN0YXJ0Tm9kZSA9IHRoaXMuYm9hcmRBcnJbeV1beFN0YXJ0Tm9kZV07XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc3RhcnROb2RlLmlkKS5jbGFzc05hbWUgPSAnc3RhcnRpbmdDZWxsJztcbiAgLy9TZXQgSW5pdGlhbCBlbmQgTm9kZVxuICB2YXIgeEZpbmFsTm9kZSA9IE1hdGguZmxvb3IoMyAqIHRoaXMuYm9hcmRBcnJbMF0ubGVuZ3RoIC8gNCk7XG4gIHRoaXMuZmluYWxOb2RlID0gdGhpcy5ib2FyZEFyclt5XVt4RmluYWxOb2RlXTtcbiAgdGhpcy5ib2FyZEFyclt5XVt4RmluYWxOb2RlXS5zdGF0dXMgPSAnZmluYWxOb2RlJztcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5maW5hbE5vZGUuaWQpLmNsYXNzTmFtZSA9ICdmaW5hbENlbGwnO1xufTtcblxuQm9hcmQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAkKFwiI2luc3RydWN0aW9uc19wYW5lbFwiKS5kcmFnZ2FibGUoKTtcbiAgLy8gJChcIiNpbnN0cnVjdGlvbnNfcGFuZWxcIikuY3NzKHsgdG9wOiAnMjAwcHgnIH0pO1xuICB2YXIgYm9hcmQgPSB0aGlzO1xuICAvL0FkZCB3aW5kb3cga2V5RG93biBldmVudCBcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGUua2V5Q29kZSA9PT0gMTYgfHwgZS5rZXlDb2RlID09PSA4NyA/IGJvYXJkLmtleURvd24gPSBlLmtleUNvZGUgOiBib2FyZC5rZXlEb3duO1xuICB9KTtcbiAgLy9BZGQgd2luZG93IGtleVVwIGV2ZW50IFxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgYm9hcmQua2V5RG93biA9IGZhbHNlO1xuICB9KTtcbiAgLy9DcmVhdGUgTW9kYWxcbiAgLy8gYm9hcmQuY3JlYXRlTW9kYWwoKVxuICAvL0FkZCBsaXN0ZW5lcnMgZm9yIHRhYmxlIGVsZW1lbnRzICBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhlaWdodDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLndpZHRoOyBqKyspIHtcbiAgICAgIHZhciBpZCA9IGoudG9TdHJpbmcoKSArICcsJyArIGkudG9TdHJpbmcoKTtcbiAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSAhPT0gJ3N0YXJ0aW5nQ2VsbCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdzdGFydGluZ0NlbGwgc2hvcnRlc3RQYXRoJyAmJiB0aGlzLmNsYXNzTmFtZSAhPT0gJ2ZpbmFsQ2VsbCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdmaW5hbENlbGxVUCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdmaW5hbENlbGxSSUdIVCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdmaW5hbENlbGxET1dOJyAmJiB0aGlzLmNsYXNzTmFtZSAhPT0gJ2ZpbmFsQ2VsbExFRlQnICYmIHRoaXMuY2xhc3NOYW1lICE9PSAnb2JqZWN0Q2VsbCcgJiYgIWJvYXJkLnNob3VsZERpc2FibGUpIHtcbiAgICAgICAgICBib2FyZC5jaGFuZ2VDZWxsQ2xpY2sodGhpcy5pZCk7XG4gICAgICAgICAgYm9hcmQubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib2FyZC5jdXJyZW50Q2VsbFN0YXR1cyA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICAgIGJvYXJkLm1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBib2FyZC5tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgYm9hcmQuY3VycmVudENlbGxTdGF0dXMgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyAgY29uc29sZS5sb2codGhpcy5jbGFzc05hbWUpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy9Ob3JtYWwgV2FsbCBDcmVhdGlvbiBEcmFnIEV2ZW50XG4gICAgICAgIGlmIChib2FyZC5tb3VzZURvd24gJiYgYm9hcmQuY3VycmVudENlbGxTdGF0dXMgPT09IG51bGwgJiYgIWJvYXJkLnNob3VsZERpc2FibGUpIHtcbiAgICAgICAgICBib2FyZC5jaGFuZ2VDZWxsRHJhZyh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICAvL0RyYWdnaW5nIGEgc3RhcnQvZW5kIG5vZGUgXG4gICAgICAgIGVsc2UgaWYgKGJvYXJkLm1vdXNlRG93biAmJiBib2FyZC5jdXJyZW50Q2VsbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmNsYXNzTmFtZSAhPT0gJ3N0YXJ0aW5nQ2VsbCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdzdGFydGluZ0NlbGwgc2hvcnRlc3RQYXRoJyAmJiB0aGlzLmNsYXNzTmFtZSAhPT0gJ2ZpbmFsQ2VsbCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdmaW5hbENlbGxVUCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdmaW5hbENlbGxSSUdIVCcgJiYgdGhpcy5jbGFzc05hbWUgIT09ICdmaW5hbENlbGxET1dOJyAmJiB0aGlzLmNsYXNzTmFtZSAhPT0gJ2ZpbmFsQ2VsbExFRlQnICYmICFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGJvYXJkLmN1cnJlbnRDZWxsU3RhdHVzO1xuICAgICAgICAgICAgdmFyIGlkU3BsaXQgPSB0aGlzLmlkLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGJvYXJkLmdldENlbGwoaWRTcGxpdFswXSwgaWRTcGxpdFsxXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUgPT09ICdzdGFydGluZ0NlbGwnIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnc3RhcnRpbmdDZWxsIHNob3J0ZXN0UGF0aCcpIHtcbiAgICAgICAgICAgICAgaWYgKGNlbGwuc3RhdHVzID09PSAnd2FsbCcpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5sYXN0V2FsbCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbC5zdGF0dXMgPT09ICd1bmV4cGxvcmVkIHdlaWdodCcpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5sYXN0V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjZWxsLnN0YXR1cyA9ICdzdGFydE5vZGUnO1xuICAgICAgICAgICAgICBib2FyZC5zdGFydE5vZGUgPSBjZWxsO1xuICAgICAgICAgICAgICBpZiAoYm9hcmQuYWxnb0RvbmUpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5jbGVhclBhdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoID0gbmV3IF9TZWFyY2gyLmRlZmF1bHQoYm9hcmQuYm9hcmRBcnIsIGJvYXJkLnN0YXJ0Tm9kZSwgYm9hcmQuZmluYWxOb2RlLCBib2FyZC5jdXJyZW50QWxnbywgYm9hcmQpO1xuICAgICAgICAgICAgICAgIHNlYXJjaC5zdGFydFNlYXJjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbFVQJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbFJJR0hUJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbERPV04nIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsTEVGVCcpIHtcbiAgICAgICAgICAgICAgaWYgKGNlbGwuc3RhdHVzID09PSAnd2FsbCcpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5sYXN0V2FsbCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbC5zdGF0dXMgPT09ICd1bmV4cGxvcmVkIHdlaWdodCcpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5sYXN0V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjZWxsLnN0YXR1cyA9ICdmaW5hbE5vZGUnO1xuICAgICAgICAgICAgICBib2FyZC5maW5hbE5vZGUgPSBjZWxsO1xuICAgICAgICAgICAgICBpZiAoYm9hcmQuYWxnb0RvbmUpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5jbGVhclBhdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoID0gbmV3IF9TZWFyY2gyLmRlZmF1bHQoYm9hcmQuYm9hcmRBcnIsIGJvYXJkLnN0YXJ0Tm9kZSwgYm9hcmQuZmluYWxOb2RlLCBib2FyZC5jdXJyZW50QWxnbywgYm9hcmQpO1xuICAgICAgICAgICAgICAgIHNlYXJjaC5zdGFydFNlYXJjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChib2FyZC5tb3VzZURvd24gJiYgYm9hcmQuY3VycmVudENlbGxTdGF0dXMgIT09IG51bGwgJiYgKHRoaXMuY2xhc3NOYW1lID09PSAnc3RhcnRpbmdDZWxsJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ3N0YXJ0aW5nQ2VsbCBzaG9ydGVzdFBhdGgnIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbFVQJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbFJJR0hUJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbERPV04nIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsTEVGVCcpICYmICFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUgPT09ICdzdGFydGluZ0NlbGwnIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnc3RhcnRpbmdDZWxsIHNob3J0ZXN0UGF0aCcpIHtcbiAgICAgICAgICAgICAgYm9hcmQuc2hvdWxkQmUgPSAnc3RhcnRpbmdDZWxsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGFzc05hbWUgPT09ICdmaW5hbENlbGwnIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsVVAnIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsUklHSFQnIHx8IHRoaXMuY2xhc3NOYW1lID09PSAnZmluYWxDZWxsRE9XTicgfHwgdGhpcy5jbGFzc05hbWUgPT09ICdmaW5hbENlbGxMRUZUJykge1xuICAgICAgICAgICAgICBib2FyZC5zaG91bGRCZSA9ICdmaW5hbENlbGwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsYXNzTmFtZSA9PT0gJ29iamVjdENlbGwnKSB7XG4gICAgICAgICAgICAgIGJvYXJkLnNob3VsZEJlID0gJ29iamVjdENlbGwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCh0aGlzLmNsYXNzTmFtZSA9PT0gJ3N0YXJ0aW5nQ2VsbCcgfHwgdGhpcy5jbGFzc05hbWUgPT09ICdzdGFydGluZ0NlbGwgc2hvcnRlc3RQYXRoJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbCcgfHwgdGhpcy5jbGFzc05hbWUgPT09ICdmaW5hbENlbGxVUCcgfHwgdGhpcy5jbGFzc05hbWUgPT09ICdmaW5hbENlbGxSSUdIVCcgfHwgdGhpcy5jbGFzc05hbWUgPT09ICdmaW5hbENlbGxET1dOJyB8fCB0aGlzLmNsYXNzTmFtZSA9PT0gJ2ZpbmFsQ2VsbExFRlQnKSAmJiAhYm9hcmQuc2hvdWxkRGlzYWJsZSkge1xuICAgICAgICAgIGlmIChib2FyZC5tb3VzZURvd24gJiYgYm9hcmQuY3VycmVudENlbGxTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChib2FyZC5zaG91bGRCZSkge1xuICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGJvYXJkLnNob3VsZEJlO1xuICAgICAgICAgICAgICBib2FyZC5zaG91bGRCZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYm9hcmQubGFzdFdhbGwpIHtcbiAgICAgICAgICAgICAgICBib2FyZC5jbGVhclBhdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgaWRTcGxpdCA9IHRoaXMuaWQuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGJvYXJkLmdldENlbGwoaWRTcGxpdFswXSwgaWRTcGxpdFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnd2FsbCc7XG4gICAgICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAnd2FsbCc7XG4gICAgICAgICAgICAgICAgYm9hcmQubGFzdFdhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChib2FyZC5sYXN0V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYm9hcmQuY2xlYXJQYXRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGlkU3BsaXQgPSB0aGlzLmlkLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBib2FyZC5nZXRDZWxsKGlkU3BsaXRbMF0sIGlkU3BsaXRbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3VuZXhwbG9yZWQgd2VpZ2h0JztcbiAgICAgICAgICAgICAgICBjZWxsLnN0YXR1cyA9ICd1bmV4cGxvcmVkIHdlaWdodCc7XG4gICAgICAgICAgICAgICAgY2VsbC53ZWlnaHQgPSAxNTtcbiAgICAgICAgICAgICAgICBib2FyZC5sYXN0V2VpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9hcmQuY2xlYXJQYXRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGlkU3BsaXQgPSB0aGlzLmlkLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBib2FyZC5nZXRDZWxsKGlkU3BsaXRbMF0sIGlkU3BsaXRbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3VuZXhwbG9yZWQnO1xuICAgICAgICAgICAgICAgIGNlbGwuc3RhdHVzID0gJ3VuZXhwbG9yZWQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy9BZGQgTGlzdGVuZXJzIGZvciBCdXR0b24gUGFuZWxcbiAgLy9CRlNcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uQkZTJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXNlJykuaW5uZXJIVE1MID0gJ1Zpc3VhbGlzZSBCRlMnO1xuICAgICAgYm9hcmQuYWxnb1RvUnVuID0gJ0JGUyc7XG4gICAgICAvLyBzZWFyY2guc3RhcnRTZWFyY2goKVxuICAgIH1cbiAgfSk7XG4gIC8vREZTXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydEJ1dHRvbkRGUycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghYm9hcmQuc2hvdWxkRGlzYWJsZSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGlzZScpLmlubmVySFRNTCA9ICdWaXN1YWxpc2UgREZTJztcbiAgICAgIGJvYXJkLmFsZ29Ub1J1biA9ICdERlMnO1xuICAgICAgLy8gc2VhcmNoLnN0YXJ0U2VhcmNoKClcbiAgICB9XG4gIH0pO1xuICAvL0RpamtzdHJhIFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b25EaWprc3RyYScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghYm9hcmQuc2hvdWxkRGlzYWJsZSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGlzZScpLmlubmVySFRNTCA9ICdWaXN1YWxpc2UgRGlqa3N0cmEnO1xuICAgICAgYm9hcmQuYWxnb1RvUnVuID0gJ0RpamtzdHJhJztcbiAgICAgIC8vIHNlYXJjaC5zdGFydFNlYXJjaCgpXG4gICAgfVxuICB9KTtcbiAgLy9GYWtlIEFTdGFyIDFcbiAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uQVN0YXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKXsgXG4gIC8vICAgaWYoIWJvYXJkLnNob3VsZERpc2FibGUpe1xuICAvLyAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGlzZScpLmlubmVySFRNTCA9ICdWaXN1YWxpc2UgU3dhcm0nXG4gIC8vICAgICBib2FyZC5hbGdvVG9SdW4gPSAnQVN0YXInXG4gIC8vICAgICAvLyBzZWFyY2guc3RhcnRTZWFyY2goKVxuICAvLyAgIH1cbiAgLy8gfSlcbiAgLy8gLy9GYWtlIEFTdGFyIDJcbiAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uQVN0YXIyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCl7ICBcbiAgLy8gICBpZighYm9hcmQuc2hvdWxkRGlzYWJsZSl7XG4gIC8vICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXNlJykuaW5uZXJIVE1MID0gJ1Zpc3VhbGlzZSBDb252ZXJnZW50IFN3YXJtJ1xuICAvLyAgICAgYm9hcmQuYWxnb1RvUnVuID0gJ0FTdGFyMidcbiAgLy8gICAgIC8vIHNlYXJjaC5zdGFydFNlYXJjaCgpXG4gIC8vICAgfVxuICAvLyB9KVxuICAvLyAvL0dyZWVkeVxuICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b25HcmVlZHknKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKXsgXG4gIC8vICAgIGlmKCFib2FyZC5zaG91bGREaXNhYmxlKXsgXG4gIC8vICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXNlJykuaW5uZXJIVE1MID0gJ1Zpc3VhbGlzZSBCZXN0IEZpcnN0IFNlYXJjaCdcbiAgLy8gICAgIGJvYXJkLmFsZ29Ub1J1biA9ICdHcmVlZHknXG4gIC8vICAgICAvLyBzZWFyY2guc3RhcnRTZWFyY2goKVxuICAvLyAgICB9XG4gIC8vIH0pXG5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uUmVhbEFTdGFyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlzdWFsaXNlJykuaW5uZXJIVE1MID0gXCJWaXN1YWxpc2UgQSpcIjtcbiAgICAgIGJvYXJkLmFsZ29Ub1J1biA9ICdSZWFsQVN0YXInO1xuICAgIH1cbiAgfSk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydEJ1dHRvbkJhc2ljTWF6ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghYm9hcmQuc2hvdWxkRGlzYWJsZSkge1xuICAgICAgdmFyIG1hemUgPSBuZXcgX01hemUyLmRlZmF1bHQoYm9hcmQsIGJvYXJkLnN0YXJ0Tm9kZSwgYm9hcmQuZmluYWxOb2RlLCAnYmFzaWNNYXplJyk7XG4gICAgICBtYXplLnN0YXJ0TWF6ZSgpO1xuICAgIH1cbiAgfSk7XG4gIC8vUmVjdXJzaXZlIERpdmlzaW9uIDFcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uQm9zc01hemUxJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICB2YXIgbWF6ZSA9IG5ldyBfTWF6ZTIuZGVmYXVsdChib2FyZCwgYm9hcmQuc3RhcnROb2RlLCBib2FyZC5maW5hbE5vZGUsICdib3NzTWF6ZTEnLCB0cnVlKTtcbiAgICAgIG1hemUuc3RhcnRNYXplKCk7XG4gICAgfVxuICB9KTtcbiAgLy9SZWN1cnNpdmUgRGl2aXNpb24gMlxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b25Cb3NzTWF6ZTInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWJvYXJkLnNob3VsZERpc2FibGUpIHtcbiAgICAgIHZhciBtYXplID0gbmV3IF9NYXplMi5kZWZhdWx0KGJvYXJkLCBib2FyZC5zdGFydE5vZGUsIGJvYXJkLmZpbmFsTm9kZSwgJ2Jvc3NNYXplMicsIHRydWUpO1xuICAgICAgbWF6ZS5zdGFydE1hemUoKTtcbiAgICB9XG4gIH0pO1xuICAvL1JlY3Vyc2l2ZSBEaXZpc2lvbiAzXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydEJ1dHRvbkJvc3NNYXplMycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghYm9hcmQuc2hvdWxkRGlzYWJsZSkge1xuICAgICAgdmFyIG1hemUgPSBuZXcgX01hemUyLmRlZmF1bHQoYm9hcmQsIGJvYXJkLnN0YXJ0Tm9kZSwgYm9hcmQuZmluYWxOb2RlLCAnYm9zc01hemUzJywgdHJ1ZSk7XG4gICAgICBtYXplLnN0YXJ0TWF6ZSgpO1xuICAgIH1cbiAgfSk7XG4gIC8vQmFzaWMgV2VpZ2h0IE1hemUgXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydEJ1dHRvbkJhc2ljV2VpZ2h0TWF6ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKGJvYXJkLnNob3VsZERpc2FibGUpO1xuICAgIGlmICghYm9hcmQuc2hvdWxkRGlzYWJsZSkge1xuICAgICAgdmFyIG1hemUgPSBuZXcgX01hemUyLmRlZmF1bHQoYm9hcmQsIGJvYXJkLnN0YXJ0Tm9kZSwgYm9hcmQuZmluYWxOb2RlLCAnYmFzaWNXZWlnaHRNYXplJywgZmFsc2UpO1xuICAgICAgbWF6ZS5zdGFydE1hemUoKTtcbiAgICB9XG4gIH0pO1xuICAvL1Bva2Vtb24gVGhlbWVcbiAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uUG9rZW1vblRoZW1lJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCl7XG4gIC8vICAgLy9cbiAgLy8gfSkgXG4gIC8vVmlzdWFsaXNlIEFsZ29yaXRobVxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b25WaXN1YWxpc2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBib2FyZC5hbGdvRG9uZSA9IGZhbHNlO1xuICAgIC8vIGNvbnNvbGUubG9nKGJvYXJkLnNob3VsZERpc2FibGUpXG4gICAgaWYgKCFib2FyZC5zaG91bGREaXNhYmxlICYmIGJvYXJkLmFsZ29Ub1J1bikge1xuICAgICAgYm9hcmQuY2xlYXJQYXRoKCk7XG4gICAgICB2YXIgYWxnb05hbWUgPSBib2FyZC5hbGdvVG9SdW47XG4gICAgICB2YXIgc2VhcmNoID0gbmV3IF9TZWFyY2gyLmRlZmF1bHQoYm9hcmQuYm9hcmRBcnIsIGJvYXJkLnN0YXJ0Tm9kZSwgYm9hcmQuZmluYWxOb2RlLCBhbGdvTmFtZSwgYm9hcmQpO1xuICAgICAgc2VhcmNoLnN0YXJ0U2VhcmNoKCk7XG4gICAgfVxuICB9KTtcbiAgLy9QYXRoXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXRoJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gIH0pO1xuICAvL0NsZWFyIFBhdGhcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnV0dG9uQ2xlYXJQYXRoJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICBib2FyZC5hbGdvRG9uZSA9IGZhbHNlO1xuICAgICAgYm9hcmQuY2xlYXJQYXRoKCk7XG4gICAgfVxuICB9KTtcbiAgLy9DbGVhciBXYWxsc1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b25DbGVhcldhbGxzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFib2FyZC5zaG91bGREaXNhYmxlKSB7XG4gICAgICBib2FyZC5jbGVhcldhbGxzKCk7XG4gICAgfVxuICB9KTtcbiAgLy9Nb2RhbCBCdXR0b25zIFxuICAvLyAvL0luY3JlbWVudCBQYWdlXG4gIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0QnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCl7XG4gIC8vICAgYm9hcmQuaW5jcmVtZW50TW9kYWwoKVxuICAvLyB9KVxuICAvLyAvL0RlY3JlbWVudCBQYWdlIFxuICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJldmlvdXNCdXR0b24nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKXtcbiAgLy8gICBib2FyZC5kZWNyZW1lbnRNb2RhbCgpXG4gIC8vIH0pIFxuICAvL0Nsb3NlIGluc3RydWN0aW9ucyBcbiAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3gnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKXtcbiAgLy8gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhbmVsUGFyZW50JykuaW5uZXJIVE1MID0gJydcbiAgLy8gICAvLyAgY29uc29sZS5sb2coXCJBU0ZcIilcbiAgLy8gICAvLyAgYm9hcmQuY2hhbmdlVG9SZWQoKVxuICAvLyB9KVxufTtcblxuQm9hcmQucHJvdG90eXBlLmdldENlbGwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICByZXR1cm4gdGhpcy5ib2FyZEFyclt5XVt4XTtcbn07XG5cbkJvYXJkLnByb3RvdHlwZS5jaGFuZ2VDZWxsQ2xpY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIG5ld0lkID0gaWQuc3BsaXQoJywnKTtcbiAgdmFyIHggPSBwYXJzZUludChuZXdJZFswXSk7XG4gIHZhciB5ID0gcGFyc2VJbnQobmV3SWRbMV0pO1xuICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcbiAgdmFyIHRvZ2dsZWRDZWxsID0gdGhpcy50b2dnbGUoY2VsbCk7XG4gIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAodG9nZ2xlZENlbGwpIHtcbiAgICBlbGVtLmNsYXNzTmFtZSA9IHRvZ2dsZWRDZWxsO1xuICB9XG59O1xuXG5Cb2FyZC5wcm90b3R5cGUuY2hhbmdlQ2VsbERyYWcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIG5ld0lkID0gaWQuc3BsaXQoJywnKTtcbiAgdmFyIHggPSBwYXJzZUludChuZXdJZFswXSk7XG4gIHZhciB5ID0gcGFyc2VJbnQobmV3SWRbMV0pO1xuICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcbiAgaWYgKGNlbGwuc3RhdHVzICE9PSAnZmluYWxDZWxsJyAmJiBjZWxsLnN0YXR1cyAhPT0gJ3N0YXJ0aW5nQ2VsbCcpIHtcbiAgICB2YXIgdG9nZ2xlZENlbGwgPSB0aGlzLnRvZ2dsZShjZWxsKTtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICBpZiAodG9nZ2xlZENlbGwpIHtcbiAgICAgIGVsZW0uY2xhc3NOYW1lID0gdG9nZ2xlZENlbGw7XG4gICAgfVxuICB9XG59O1xuXG5Cb2FyZC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgaWYgKGNlbGwuc3RhdHVzID09PSAndW5leHBsb3JlZCcgJiYgdGhpcy5rZXlEb3duIHx8IGNlbGwuc3RhdHVzID09PSAnZXhwbG9yZWQnICYmIHRoaXMua2V5RG93biB8fCBjZWxsLnN0YXR1cyA9PT0gJ3dhbGwnICYmIHRoaXMua2V5RG93bikge1xuICAgIC8vIGNlbGwuc3RhdHVzID0gJ3VuZXhwbG9yZWQgd2F0ZXInXG4gICAgaWYgKHRoaXMua2V5RG93biA9PT0gODcpIHtcbiAgICAgIGNlbGwud2VpZ2h0ID0gMTU7XG4gICAgICBjZWxsLnN0YXR1cyA9ICd1bmV4cGxvcmVkIHdlaWdodCc7XG4gICAgICByZXR1cm4gY2VsbC5zdGF0dXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNlbGwuc3RhdHVzID09PSAndW5leHBsb3JlZCcgfHwgY2VsbC5zdGF0dXMgPT09ICdleHBsb3JlZCcpIHtcbiAgICBjZWxsLnN0YXR1cyA9ICd3YWxsJztcbiAgICByZXR1cm4gY2VsbC5zdGF0dXM7XG4gIH0gZWxzZSBpZiAoY2VsbC5zdGF0dXMgPT09ICdleHBsb3JlZCB3ZWlnaHQnIHx8IGNlbGwuc3RhdHVzID09PSAndW5leHBsb3JlZCB3ZWlnaHQnKSB7XG4gICAgY2VsbC5zdGF0dXMgPSAndW5leHBsb3JlZCc7XG4gICAgY2VsbC53ZWlnaHQgPSAwO1xuICAgIHJldHVybiBjZWxsLnN0YXR1cztcbiAgfSBlbHNlIGlmIChjZWxsLnN0YXR1cyA9PT0gJ3dhbGwnKSB7XG4gICAgY2VsbC5zdGF0dXMgPSAndW5leHBsb3JlZCc7XG4gICAgcmV0dXJuIGNlbGwuc3RhdHVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmNyZWF0ZU1vZGFsID0gZnVuY3Rpb24gKCkge1xuICAvLyBHZXQgdGhlIG1vZGFsXG4gIHZhciBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteU1vZGFsJyk7XG4gIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIG1vZGFsLmhlaWdodCA9IFwiNTAwcHhcIjtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lubmVyRGlzcGxheScpLmlubmVySFRNTCA9IHRoaXMubW9kYWxBcnJbdGhpcy5tb2RhbEluZGV4XTtcblxuICAvLyBHZXQgdGhlIDxzcGFuPiBlbGVtZW50IHRoYXQgY2xvc2VzIHRoZSBtb2RhbFxuICB2YXIgc3BhbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJjbG9zZVwiKVswXTtcblxuICAvLyBXaGVuIHRoZSB1c2VyIGNsaWNrcyBvbiA8c3Bhbj4gKHgpLCBjbG9zZSB0aGUgbW9kYWxcbiAgc3Bhbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfTtcblxuICAvLyBXaGVuIHRoZSB1c2VyIGNsaWNrcyBhbnl3aGVyZSBvdXRzaWRlIG9mIHRoZSBtb2RhbCwgY2xvc2UgaXRcbiAgLy8gd2luZG93Lm9uY2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuICAvLyAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSBtb2RhbCkge1xuICAvLyAgICAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgLy8gICAgIH1cbiAgLy8gfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmluY3JlbWVudE1vZGFsID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZygnSlFVRVJZJywgJChcIiNteU1vZGFsXCIpKTtcbiAgaWYgKHRoaXMubW9kYWxJbmRleCA8IHRoaXMubW9kYWxBcnIubGVuZ3RoIC0gMSkge1xuICAgIHRoaXMubW9kYWxJbmRleCArPSAxO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbm5lckRpc3BsYXknKS5pbm5lckhUTUwgPSB0aGlzLm1vZGFsQXJyW3RoaXMubW9kYWxJbmRleF07XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RhbEluZGV4ID09PSB0aGlzLm1vZGFsQXJyLmxlbmd0aCAtIDEpIHtcbiAgICB2YXIgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlNb2RhbCcpO1xuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmRlY3JlbWVudE1vZGFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5tb2RhbEluZGV4ID4gMCkge1xuICAgIHRoaXMubW9kYWxJbmRleCAtPSAxO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbm5lckRpc3BsYXknKS5pbm5lckhUTUwgPSB0aGlzLm1vZGFsQXJyW3RoaXMubW9kYWxJbmRleF07XG4gIH1cbn07XG5cbkJvYXJkLnByb3RvdHlwZS5jaGFuZ2VUb1JlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0b2dnbGVDb2xvdXInKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc3VhbGlzZScpLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGxpc3RbaV0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmNoYW5nZUZyb21SZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndG9nZ2xlQ29sb3VyJyk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpc2UnKS5zdHlsZS5jb2xvciA9ICdlMWU0ZTcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0W2ldLnN0eWxlLmNvbG9yID0gJ2UxZTRlNyc7XG4gIH1cbn07XG5cbkJvYXJkLnByb3RvdHlwZS5jbGVhclBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZmluYWxOb2RlLmlkKS5jbGFzc05hbWUgPSAnZmluYWxDZWxsJztcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5zdGFydE5vZGUuaWQpLmNsYXNzTmFtZSA9ICdzdGFydGluZ0NlbGwnO1xuICAvLyBjb25zb2xlLmxvZygnaW4gY2xlYXIgcGF0aCcpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2FyZEFyci5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5ib2FyZEFycltpXS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGNlbGwgPSB0aGlzLmJvYXJkQXJyW2ldW2pdO1xuICAgICAgY2VsbC5wYXJlbnQgPSBudWxsO1xuICAgICAgaWYgKGNlbGwuc3RhdHVzID09PSAnZXhwbG9yZWQnIHx8IGNlbGwuc3RhdHVzID09PSAnc2hvcnRlc3RQYXRoJykge1xuICAgICAgICBjZWxsLnN0YXR1cyA9ICd1bmV4cGxvcmVkJztcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2VsbC5pZCkuY2xhc3NOYW1lID0gJ3VuZXhwbG9yZWQnO1xuICAgICAgfSBlbHNlIGlmIChjZWxsLnN0YXR1cyA9PT0gJ3Nob3J0ZXN0UGF0aCBleHBsb3JlZCB3ZWlnaHQnIHx8IGNlbGwuc3RhdHVzID09PSAnZXhwbG9yZWQgd2VpZ2h0Jykge1xuICAgICAgICBjZWxsLnN0YXR1cyA9ICd1bmV4cGxvcmVkIHdlaWdodCc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNlbGwuaWQpLmNsYXNzTmFtZSA9ICd1bmV4cGxvcmVkIHdlaWdodCc7XG4gICAgICB9XG4gICAgICBpZiAoY2VsbC5zdGF0dXMgIT09ICdzdGFydE5vZGUnKSB7XG4gICAgICAgIGNlbGwuZGlyZWN0aW9uID0gJ1VQJztcbiAgICAgICAgY2VsbC5kaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmNsZWFyUGFyZW50cyA9IGZ1bmN0aW9uIChzaG93KSB7XG4gIGNvbnNvbGUubG9nKFwiY2xlYXIgUGFyZW50c1wiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvYXJkQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmJvYXJkQXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY2VsbCA9IHRoaXMuYm9hcmRBcnJbaV1bal07XG4gICAgICBpZiAoIXNob3cgJiYgY2VsbC5zdGF0dXMgIT09ICdzaG9ydGVzdFBhdGgnICYmIGNlbGwuc3RhdHVzICE9PSAnb2JqZWN0Tm9kZScgJiYgY2VsbC5zdGF0dXMgIT09ICdzdGFydE5vZGUnKSB7XG4gICAgICAgIGNlbGwucGFyZW50ID0gbnVsbDtcbiAgICAgICAgY2VsbC5kaXJlY3Rpb24gPSAnVVAnO1xuICAgICAgICBjZWxsLmRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdykge1xuICAgICAgICBjb25zb2xlLmxvZyhjZWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkJvYXJkLnByb3RvdHlwZS5jbGVhcldhbGxzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9hcmRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYm9hcmRBcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBjZWxsID0gdGhpcy5ib2FyZEFycltpXVtqXTtcbiAgICAgIGNlbGwucGFyZW50ID0gbnVsbDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGosaSxjZWxsKVxuICAgICAgaWYgKGNlbGwuc3RhdHVzID09PSAnd2FsbCcgfHwgY2VsbC5zdGF0dXMgPT09ICd1bmV4cGxvcmVkIHdlaWdodCcpIHtcbiAgICAgICAgY2VsbC5zdGF0dXMgPSAndW5leHBsb3JlZCc7XG4gICAgICAgIGNlbGwud2VpZ2h0ID0gMDtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2VsbC5pZCkuY2xhc3NOYW1lID0gJ3VuZXhwbG9yZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZyhcIkdlbmVyYXRpbmcgcmFuZG9tIE1hemVcIik7XG59O1xuXG52YXIgYmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25hdmJhckRpdicpLmNsaWVudEhlaWdodCArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluVGV4dCcpLmNsaWVudEhlaWdodDtcbnZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIC0gYmFyO1xudmFyIHdpZHRoID0gTWF0aC5mbG9vcihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpO1xudmFyIGZpbmFsSGVpZ2h0ID0gaGVpZ2h0IC8gMjc7XG52YXIgZmluYWxXaWR0aCA9IHdpZHRoIC8gMjU7XG4kKFwiI2luc3RydWN0aW9uc19wYW5lbFwiKS5jc3MoeyB0b3A6IGZpbmFsSGVpZ2h0ICogMjcgLyA0ICsgJ3B4JyB9KTtcbiQoXCIjaW5zdHJ1Y3Rpb25zX3BhbmVsXCIpLmNzcyh7IGxlZnQ6IGZpbmFsV2lkdGggKiAyNSAvIDMuNSArICdweCcgfSk7XG52YXIgYm9hcmQgPSBuZXcgQm9hcmQoZmluYWxIZWlnaHQsIGZpbmFsV2lkdGggLSAxKTtcbi8vIHZhciBib2FyZCA9IG5ldyBCb2FyZCgxMCwxMClcbmJvYXJkLmluaXRpYWxpc2UoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * JavaScript Programmed By SOULEYMANE DEMBELE 09/20/2019\n */\nvar Cell = function Cell(xPos, yPos) {\n  _classCallCheck(this, Cell);\n\n  this.x = xPos;\n  this.y = yPos;\n  this.exploredBy = null;\n  this.status = 'unexplored';\n  this.id = this.x.toString() + ',' + this.y.toString();\n  this.weight = 0;\n  this.parent = null;\n  this.direction = 'UP';\n  this.distance = Infinity;\n  this.heuristicDistance = 0;\n  this.totalDistance = Infinity;\n  this.previousStatus = 'unexplored';\n};\n\nCell.prototype.getCellStatus = function () {\n  return this.status;\n};\n\nexports.default = Cell;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9DZWxsLmpzPzRhZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEphdmFTY3JpcHQgUHJvZ3JhbW1lZCBCeSBTT1VMRVlNQU5FIERFTUJFTEUgMDkvMjAvMjAxOVxuICovXG52YXIgQ2VsbCA9IGZ1bmN0aW9uIENlbGwoeFBvcywgeVBvcykge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VsbCk7XG5cbiAgdGhpcy54ID0geFBvcztcbiAgdGhpcy55ID0geVBvcztcbiAgdGhpcy5leHBsb3JlZEJ5ID0gbnVsbDtcbiAgdGhpcy5zdGF0dXMgPSAndW5leHBsb3JlZCc7XG4gIHRoaXMuaWQgPSB0aGlzLngudG9TdHJpbmcoKSArICcsJyArIHRoaXMueS50b1N0cmluZygpO1xuICB0aGlzLndlaWdodCA9IDA7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5kaXJlY3Rpb24gPSAnVVAnO1xuICB0aGlzLmRpc3RhbmNlID0gSW5maW5pdHk7XG4gIHRoaXMuaGV1cmlzdGljRGlzdGFuY2UgPSAwO1xuICB0aGlzLnRvdGFsRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgdGhpcy5wcmV2aW91c1N0YXR1cyA9ICd1bmV4cGxvcmVkJztcbn07XG5cbkNlbGwucHJvdG90eXBlLmdldENlbGxTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0YXR1cztcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENlbGw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvQ2VsbC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * JavaScript Program Modified By SOULEYMANE DEMBELE 09/23/2019\n */\nvar Maze = function Maze(board, startNode, finalNode, mazeToDo, animate) {\n    _classCallCheck(this, Maze);\n\n    this.board = board;\n    this.boardArr = board.boardArr;\n    this.startNode = startNode;\n    this.finalNode = finalNode;\n    this.listToAnimate = [];\n    this.mazeToDo = mazeToDo;\n    this.toAnimate = animate;\n};\n\nMaze.prototype.startMaze = function () {\n    this.board.shouldDisable = true;\n    this.board.clearWalls();\n    this.board.clearPath();\n    this.maxX = this.boardArr[0].length;\n    this.maxY = this.boardArr.length;\n    if (this.mazeToDo === 'basicMaze') {\n        this.basicMaze();\n        this.toAnimate === true ? this.animate() : this.instant();\n    } else if (this.mazeToDo === 'bossMaze1') {\n        this.mazeGenerator();\n        this.toAnimate === true ? this.animate() : this.instant();\n    } else if (this.mazeToDo === 'bossMaze2') {\n        this.mazeGenerator();\n        this.toAnimate === true ? this.animate() : this.instant();\n    } else if (this.mazeToDo === 'bossMaze3') {\n        this.mazeGenerator();\n        this.toAnimate === true ? this.animate() : this.instant();\n    } else if (this.mazeToDo === 'basicWeightMaze') {\n        this.basicWeightMaze();\n        this.toAnimate === true ? this.animate() : this.instant();\n    }\n};\n\nMaze.prototype.basicMaze = function () {\n    for (var i = 0; i < this.boardArr.length; i++) {\n        for (var j = 0; j < this.boardArr[0].length; j++) {\n            var elem = document.getElementById(j.toString() + ',' + i.toString());\n            if (Math.random() > 0.75 && elem.className !== 'startingCell' && elem.className !== 'finalCell') {\n                var cell = this.board.getCell(j, i);\n                cell.status = 'wall';\n                this.listToAnimate.push(cell);\n            }\n        }\n    }\n};\n\nMaze.prototype.basicWeightMaze = function () {\n    for (var i = 0; i < this.boardArr.length; i++) {\n        for (var j = 0; j < this.boardArr[0].length; j++) {\n            var elem = document.getElementById(j.toString() + ',' + i.toString());\n            if (Math.random() > 0.75 && elem.className !== 'startingCell' && elem.className !== 'finalCell') {\n                var cell = this.board.getCell(j, i);\n                cell.status = 'unexplored weight';\n                cell.weight = 15;\n                this.listToAnimate.push(cell);\n            }\n        }\n    }\n};\n\nMaze.prototype.mazeGenerator = function () {\n    for (var i = 0; i < this.maxY; i++) {\n        for (var j = 0; j < this.maxX; j++) {\n            if (i === 0 || i === this.maxY - 1 || j === 0 || j === this.maxX - 1) {\n                var cell = this.board.getCell(j, i);\n                if (cell.status !== 'startNode' && cell.status !== 'finalNode') {\n                    cell.status = 'wall';\n                    this.listToAnimate.push(cell);\n                }\n            }\n        }\n    }\n    this.bossMaze(2, this.boardArr[0].length - 3, 2, this.boardArr.length - 3, 'horizontal');\n};\n\nMaze.prototype.bossMaze = function (startX, endX, startY, endY, orientation) {\n    if (orientation === 'vertical') {\n        if (startX % 2 === 0 && endY - startY > -1 && endX - startX > -1) {\n            var validWall = [];\n            for (var i = startX; i < endX + 1; i += 2) {\n                validWall.push(i);\n            }\n            var randomX = validWall[Math.floor(Math.random() * validWall.length)];\n            this.drawWall(randomX, randomX, startY, endY, 'vertical');\n            var splitArr = [];\n            for (var i = startY - 1; i < endY + 2; i += 2) {\n                splitArr.push(randomX.toString() + ',' + i.toString());\n            }\n            var randomPlaceToSplitID = splitArr[Math.floor(Math.random() * splitArr.length)];\n            var elem = document.getElementById(randomPlaceToSplitID);\n            var idArr = randomPlaceToSplitID.split(',');\n            var cell = this.board.getCell(parseInt(idArr[0]), parseInt(idArr[1]));\n            if (cell.status !== 'startNode' && cell.status !== 'finalNode') {\n                cell.status = 'unexplored';\n                this.listToAnimate.push(cell);\n            }\n\n            var lengthLargerThanHeightLeft = !this.lengthLargerThanHeight(startX, randomX - 2, startY, endY);\n            var lengthLargerThanHeightRight;\n            if (this.mazeToDo === 'bossMaze 1' || this.mazeToDo === 'bossMaze2') {\n                lengthLargerThanHeightRight = !this.lengthLargerThanHeight(randomX + 2, endX, startY, endY);\n            } else if (this.mazeToDo === 'bossMaze3') {\n                lengthLargerThanHeightRight = this.lengthLargerThanHeight(randomX + 2, endX, startY, endY);\n            }\n            if (lengthLargerThanHeightLeft) {\n                this.bossMaze(startX, randomX - 2, startY, endY, 'horizontal');\n            } else {\n                this.bossMaze(startX, randomX - 2, startY, endY, 'vertical');\n            }\n            if (lengthLargerThanHeightRight) {\n                this.bossMaze(randomX + 2, endX, startY, endY, 'horizontal');\n            } else {\n                this.bossMaze(randomX + 2, endX, startY, endY, 'vertical');\n            }\n        } else {\n            return;\n        }\n    } else if (orientation === 'horizontal') {\n        if (startY % 2 === 0 && endY - startY > -1 && endX - startX > -1) {\n            var validWall = [];\n            for (var i = startY; i < endY + 1; i += 2) {\n                validWall.push(i);\n            }\n            var randomY = validWall[Math.floor(Math.random() * validWall.length)];\n            /**Draw Walls */\n            this.drawWall(startX, endX, randomY, randomY, 'horizontal');\n            var splitArr = [];\n            for (var i = startX - 1; i < endX + 2; i += 2) {\n                splitArr.push(i.toString() + ',' + randomY.toString());\n            }\n            var randomPlaceToSplitID = splitArr[Math.floor(Math.random() * splitArr.length)];\n            var elem = document.getElementById(randomPlaceToSplitID);\n            var idArr = randomPlaceToSplitID.split(',');\n            var cell = this.board.getCell(parseInt(idArr[0]), parseInt(idArr[1]));\n            if (cell.status !== 'startNode' && cell.status !== 'finalNode') {\n                cell.status = 'unexplored';\n                this.listToAnimate.push(cell);\n            }\n\n            var lengthLargerThanHeightTop = !this.lengthLargerThanHeight(startX, endX, startY, randomY - 2);\n            var lengthLargerThanHeightBottom;\n            if (this.mazeToDo === 'bossMaze1' || this.mazeToDo === 'bossMaze3') {\n                lengthLargerThanHeightBottom = !this.lengthLargerThanHeight(startX, endX, randomY + 2, endY);\n            } else if (this.mazeToDo === 'bossMaze2') {\n                lengthLargerThanHeightBottom = this.lengthLargerThanHeight(startX, endX, randomY + 2, endY);\n            }\n            if (lengthLargerThanHeightTop) {\n                this.bossMaze(startX, endX, startY, randomY - 2, 'horizontal');\n            } else {\n                this.bossMaze(startX, endX, startY, randomY - 2, 'vertical');\n            }\n            if (lengthLargerThanHeightBottom) {\n                this.bossMaze(startX, endX, randomY + 2, endY, 'horizontal');\n            } else {\n                this.bossMaze(startX, endX, randomY + 2, endY, 'vertical');\n            }\n        } else {\n            return;\n        }\n    }\n};\n\nMaze.prototype.drawWall = function (startX, endX, startY, endY, orientation) {\n    if (orientation === 'vertical') {\n        for (var i = startY - 1; i < endY + 2; i++) {\n            var elem = document.getElementById(startX.toString() + ',' + i.toString());\n            var cell = this.board.getCell(startX, i);\n            if (cell.status !== 'startNode' && cell.status !== 'finalNode') {\n                cell.status = 'wall';\n                this.listToAnimate.push(cell);\n            }\n        }\n    } else if (orientation === 'horizontal') {\n        for (var j = startX - 1; j < endX + 2; j++) {\n            var elem = document.getElementById(j.toString() + ',' + startY.toString());\n            var cell = this.board.getCell(j, startY);\n            if (cell.status !== 'startNode' && cell.status !== 'finalNode') {\n                cell.status = 'wall';\n                this.listToAnimate.push(cell);\n            }\n        }\n    }\n};\n\nMaze.prototype.lengthLargerThanHeight = function (startX, endX, startY, endY) {\n    var returnVal = endX - startX - (endY - startY) > 0;\n    return returnVal;\n};\n\nMaze.prototype.animate = function () {\n    var self = this;\n    var list = this.listToAnimate;\n    function timeout(index) {\n        setTimeout(function () {\n            if (index === list.length) {\n                self.board.shouldDisable = false;\n                return;\n            }\n            var cell = list[index];\n            document.getElementById(cell.id).className = cell.status;\n            timeout(index + 1);\n        }, 0.0001);\n    }\n    timeout(0);\n};\n\nMaze.prototype.instant = function () {\n    for (var i in this.listToAnimate) {\n        var cell = this.listToAnimate[i];\n        document.getElementById(cell.id).className = cell.status;\n    }\n    this.board.shouldDisable = false;\n};\n\nexports.default = Maze;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9NYXplLmpzPzM0MDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSmF2YVNjcmlwdCBQcm9ncmFtIE1vZGlmaWVkIEJ5IFNPVUxFWU1BTkUgREVNQkVMRSAwOS8yMy8yMDE5XG4gKi9cbnZhciBNYXplID0gZnVuY3Rpb24gTWF6ZShib2FyZCwgc3RhcnROb2RlLCBmaW5hbE5vZGUsIG1hemVUb0RvLCBhbmltYXRlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hemUpO1xuXG4gICAgdGhpcy5ib2FyZCA9IGJvYXJkO1xuICAgIHRoaXMuYm9hcmRBcnIgPSBib2FyZC5ib2FyZEFycjtcbiAgICB0aGlzLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICB0aGlzLmZpbmFsTm9kZSA9IGZpbmFsTm9kZTtcbiAgICB0aGlzLmxpc3RUb0FuaW1hdGUgPSBbXTtcbiAgICB0aGlzLm1hemVUb0RvID0gbWF6ZVRvRG87XG4gICAgdGhpcy50b0FuaW1hdGUgPSBhbmltYXRlO1xufTtcblxuTWF6ZS5wcm90b3R5cGUuc3RhcnRNYXplID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYm9hcmQuc2hvdWxkRGlzYWJsZSA9IHRydWU7XG4gICAgdGhpcy5ib2FyZC5jbGVhcldhbGxzKCk7XG4gICAgdGhpcy5ib2FyZC5jbGVhclBhdGgoKTtcbiAgICB0aGlzLm1heFggPSB0aGlzLmJvYXJkQXJyWzBdLmxlbmd0aDtcbiAgICB0aGlzLm1heFkgPSB0aGlzLmJvYXJkQXJyLmxlbmd0aDtcbiAgICBpZiAodGhpcy5tYXplVG9EbyA9PT0gJ2Jhc2ljTWF6ZScpIHtcbiAgICAgICAgdGhpcy5iYXNpY01hemUoKTtcbiAgICAgICAgdGhpcy50b0FuaW1hdGUgPT09IHRydWUgPyB0aGlzLmFuaW1hdGUoKSA6IHRoaXMuaW5zdGFudCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXplVG9EbyA9PT0gJ2Jvc3NNYXplMScpIHtcbiAgICAgICAgdGhpcy5tYXplR2VuZXJhdG9yKCk7XG4gICAgICAgIHRoaXMudG9BbmltYXRlID09PSB0cnVlID8gdGhpcy5hbmltYXRlKCkgOiB0aGlzLmluc3RhbnQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF6ZVRvRG8gPT09ICdib3NzTWF6ZTInKSB7XG4gICAgICAgIHRoaXMubWF6ZUdlbmVyYXRvcigpO1xuICAgICAgICB0aGlzLnRvQW5pbWF0ZSA9PT0gdHJ1ZSA/IHRoaXMuYW5pbWF0ZSgpIDogdGhpcy5pbnN0YW50KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hemVUb0RvID09PSAnYm9zc01hemUzJykge1xuICAgICAgICB0aGlzLm1hemVHZW5lcmF0b3IoKTtcbiAgICAgICAgdGhpcy50b0FuaW1hdGUgPT09IHRydWUgPyB0aGlzLmFuaW1hdGUoKSA6IHRoaXMuaW5zdGFudCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXplVG9EbyA9PT0gJ2Jhc2ljV2VpZ2h0TWF6ZScpIHtcbiAgICAgICAgdGhpcy5iYXNpY1dlaWdodE1hemUoKTtcbiAgICAgICAgdGhpcy50b0FuaW1hdGUgPT09IHRydWUgPyB0aGlzLmFuaW1hdGUoKSA6IHRoaXMuaW5zdGFudCgpO1xuICAgIH1cbn07XG5cbk1hemUucHJvdG90eXBlLmJhc2ljTWF6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9hcmRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmJvYXJkQXJyWzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGoudG9TdHJpbmcoKSArICcsJyArIGkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNzUgJiYgZWxlbS5jbGFzc05hbWUgIT09ICdzdGFydGluZ0NlbGwnICYmIGVsZW0uY2xhc3NOYW1lICE9PSAnZmluYWxDZWxsJykge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5ib2FyZC5nZXRDZWxsKGosIGkpO1xuICAgICAgICAgICAgICAgIGNlbGwuc3RhdHVzID0gJ3dhbGwnO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFRvQW5pbWF0ZS5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuTWF6ZS5wcm90b3R5cGUuYmFzaWNXZWlnaHRNYXplID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2FyZEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYm9hcmRBcnJbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoai50b1N0cmluZygpICsgJywnICsgaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC43NSAmJiBlbGVtLmNsYXNzTmFtZSAhPT0gJ3N0YXJ0aW5nQ2VsbCcgJiYgZWxlbS5jbGFzc05hbWUgIT09ICdmaW5hbENlbGwnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmJvYXJkLmdldENlbGwoaiwgaSk7XG4gICAgICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAndW5leHBsb3JlZCB3ZWlnaHQnO1xuICAgICAgICAgICAgICAgIGNlbGwud2VpZ2h0ID0gMTU7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0VG9BbmltYXRlLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NYXplLnByb3RvdHlwZS5tYXplR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXhZOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1heFg7IGorKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gdGhpcy5tYXhZIC0gMSB8fCBqID09PSAwIHx8IGogPT09IHRoaXMubWF4WCAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuYm9hcmQuZ2V0Q2VsbChqLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5zdGF0dXMgIT09ICdzdGFydE5vZGUnICYmIGNlbGwuc3RhdHVzICE9PSAnZmluYWxOb2RlJykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnN0YXR1cyA9ICd3YWxsJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0VG9BbmltYXRlLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm9zc01hemUoMiwgdGhpcy5ib2FyZEFyclswXS5sZW5ndGggLSAzLCAyLCB0aGlzLmJvYXJkQXJyLmxlbmd0aCAtIDMsICdob3Jpem9udGFsJyk7XG59O1xuXG5NYXplLnByb3RvdHlwZS5ib3NzTWF6ZSA9IGZ1bmN0aW9uIChzdGFydFgsIGVuZFgsIHN0YXJ0WSwgZW5kWSwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgaWYgKHN0YXJ0WCAlIDIgPT09IDAgJiYgZW5kWSAtIHN0YXJ0WSA+IC0xICYmIGVuZFggLSBzdGFydFggPiAtMSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkV2FsbCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0WDsgaSA8IGVuZFggKyAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YWxpZFdhbGwucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5kb21YID0gdmFsaWRXYWxsW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbGlkV2FsbC5sZW5ndGgpXTtcbiAgICAgICAgICAgIHRoaXMuZHJhd1dhbGwocmFuZG9tWCwgcmFuZG9tWCwgc3RhcnRZLCBlbmRZLCAndmVydGljYWwnKTtcbiAgICAgICAgICAgIHZhciBzcGxpdEFyciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0WSAtIDE7IGkgPCBlbmRZICsgMjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRBcnIucHVzaChyYW5kb21YLnRvU3RyaW5nKCkgKyAnLCcgKyBpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmRvbVBsYWNlVG9TcGxpdElEID0gc3BsaXRBcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc3BsaXRBcnIubGVuZ3RoKV07XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhbmRvbVBsYWNlVG9TcGxpdElEKTtcbiAgICAgICAgICAgIHZhciBpZEFyciA9IHJhbmRvbVBsYWNlVG9TcGxpdElELnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuYm9hcmQuZ2V0Q2VsbChwYXJzZUludChpZEFyclswXSksIHBhcnNlSW50KGlkQXJyWzFdKSk7XG4gICAgICAgICAgICBpZiAoY2VsbC5zdGF0dXMgIT09ICdzdGFydE5vZGUnICYmIGNlbGwuc3RhdHVzICE9PSAnZmluYWxOb2RlJykge1xuICAgICAgICAgICAgICAgIGNlbGwuc3RhdHVzID0gJ3VuZXhwbG9yZWQnO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFRvQW5pbWF0ZS5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoTGFyZ2VyVGhhbkhlaWdodExlZnQgPSAhdGhpcy5sZW5ndGhMYXJnZXJUaGFuSGVpZ2h0KHN0YXJ0WCwgcmFuZG9tWCAtIDIsIHN0YXJ0WSwgZW5kWSk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoTGFyZ2VyVGhhbkhlaWdodFJpZ2h0O1xuICAgICAgICAgICAgaWYgKHRoaXMubWF6ZVRvRG8gPT09ICdib3NzTWF6ZSAxJyB8fCB0aGlzLm1hemVUb0RvID09PSAnYm9zc01hemUyJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aExhcmdlclRoYW5IZWlnaHRSaWdodCA9ICF0aGlzLmxlbmd0aExhcmdlclRoYW5IZWlnaHQocmFuZG9tWCArIDIsIGVuZFgsIHN0YXJ0WSwgZW5kWSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF6ZVRvRG8gPT09ICdib3NzTWF6ZTMnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoTGFyZ2VyVGhhbkhlaWdodFJpZ2h0ID0gdGhpcy5sZW5ndGhMYXJnZXJUaGFuSGVpZ2h0KHJhbmRvbVggKyAyLCBlbmRYLCBzdGFydFksIGVuZFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aExhcmdlclRoYW5IZWlnaHRMZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3NzTWF6ZShzdGFydFgsIHJhbmRvbVggLSAyLCBzdGFydFksIGVuZFksICdob3Jpem9udGFsJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9zc01hemUoc3RhcnRYLCByYW5kb21YIC0gMiwgc3RhcnRZLCBlbmRZLCAndmVydGljYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGhMYXJnZXJUaGFuSGVpZ2h0UmlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvc3NNYXplKHJhbmRvbVggKyAyLCBlbmRYLCBzdGFydFksIGVuZFksICdob3Jpem9udGFsJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9zc01hemUocmFuZG9tWCArIDIsIGVuZFgsIHN0YXJ0WSwgZW5kWSwgJ3ZlcnRpY2FsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgaWYgKHN0YXJ0WSAlIDIgPT09IDAgJiYgZW5kWSAtIHN0YXJ0WSA+IC0xICYmIGVuZFggLSBzdGFydFggPiAtMSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkV2FsbCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0WTsgaSA8IGVuZFkgKyAxOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YWxpZFdhbGwucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5kb21ZID0gdmFsaWRXYWxsW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHZhbGlkV2FsbC5sZW5ndGgpXTtcbiAgICAgICAgICAgIC8qKkRyYXcgV2FsbHMgKi9cbiAgICAgICAgICAgIHRoaXMuZHJhd1dhbGwoc3RhcnRYLCBlbmRYLCByYW5kb21ZLCByYW5kb21ZLCAnaG9yaXpvbnRhbCcpO1xuICAgICAgICAgICAgdmFyIHNwbGl0QXJyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRYIC0gMTsgaSA8IGVuZFggKyAyOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEFyci5wdXNoKGkudG9TdHJpbmcoKSArICcsJyArIHJhbmRvbVkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmFuZG9tUGxhY2VUb1NwbGl0SUQgPSBzcGxpdEFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzcGxpdEFyci5sZW5ndGgpXTtcbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmFuZG9tUGxhY2VUb1NwbGl0SUQpO1xuICAgICAgICAgICAgdmFyIGlkQXJyID0gcmFuZG9tUGxhY2VUb1NwbGl0SUQuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5ib2FyZC5nZXRDZWxsKHBhcnNlSW50KGlkQXJyWzBdKSwgcGFyc2VJbnQoaWRBcnJbMV0pKTtcbiAgICAgICAgICAgIGlmIChjZWxsLnN0YXR1cyAhPT0gJ3N0YXJ0Tm9kZScgJiYgY2VsbC5zdGF0dXMgIT09ICdmaW5hbE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAndW5leHBsb3JlZCc7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0VG9BbmltYXRlLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZW5ndGhMYXJnZXJUaGFuSGVpZ2h0VG9wID0gIXRoaXMubGVuZ3RoTGFyZ2VyVGhhbkhlaWdodChzdGFydFgsIGVuZFgsIHN0YXJ0WSwgcmFuZG9tWSAtIDIpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aExhcmdlclRoYW5IZWlnaHRCb3R0b207XG4gICAgICAgICAgICBpZiAodGhpcy5tYXplVG9EbyA9PT0gJ2Jvc3NNYXplMScgfHwgdGhpcy5tYXplVG9EbyA9PT0gJ2Jvc3NNYXplMycpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGhMYXJnZXJUaGFuSGVpZ2h0Qm90dG9tID0gIXRoaXMubGVuZ3RoTGFyZ2VyVGhhbkhlaWdodChzdGFydFgsIGVuZFgsIHJhbmRvbVkgKyAyLCBlbmRZKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXplVG9EbyA9PT0gJ2Jvc3NNYXplMicpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGhMYXJnZXJUaGFuSGVpZ2h0Qm90dG9tID0gdGhpcy5sZW5ndGhMYXJnZXJUaGFuSGVpZ2h0KHN0YXJ0WCwgZW5kWCwgcmFuZG9tWSArIDIsIGVuZFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aExhcmdlclRoYW5IZWlnaHRUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvc3NNYXplKHN0YXJ0WCwgZW5kWCwgc3RhcnRZLCByYW5kb21ZIC0gMiwgJ2hvcml6b250YWwnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3NzTWF6ZShzdGFydFgsIGVuZFgsIHN0YXJ0WSwgcmFuZG9tWSAtIDIsICd2ZXJ0aWNhbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aExhcmdlclRoYW5IZWlnaHRCb3R0b20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvc3NNYXplKHN0YXJ0WCwgZW5kWCwgcmFuZG9tWSArIDIsIGVuZFksICdob3Jpem9udGFsJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9zc01hemUoc3RhcnRYLCBlbmRYLCByYW5kb21ZICsgMiwgZW5kWSwgJ3ZlcnRpY2FsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NYXplLnByb3RvdHlwZS5kcmF3V2FsbCA9IGZ1bmN0aW9uIChzdGFydFgsIGVuZFgsIHN0YXJ0WSwgZW5kWSwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0WSAtIDE7IGkgPCBlbmRZICsgMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0YXJ0WC50b1N0cmluZygpICsgJywnICsgaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5ib2FyZC5nZXRDZWxsKHN0YXJ0WCwgaSk7XG4gICAgICAgICAgICBpZiAoY2VsbC5zdGF0dXMgIT09ICdzdGFydE5vZGUnICYmIGNlbGwuc3RhdHVzICE9PSAnZmluYWxOb2RlJykge1xuICAgICAgICAgICAgICAgIGNlbGwuc3RhdHVzID0gJ3dhbGwnO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdFRvQW5pbWF0ZS5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBzdGFydFggLSAxOyBqIDwgZW5kWCArIDI7IGorKykge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChqLnRvU3RyaW5nKCkgKyAnLCcgKyBzdGFydFkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuYm9hcmQuZ2V0Q2VsbChqLCBzdGFydFkpO1xuICAgICAgICAgICAgaWYgKGNlbGwuc3RhdHVzICE9PSAnc3RhcnROb2RlJyAmJiBjZWxsLnN0YXR1cyAhPT0gJ2ZpbmFsTm9kZScpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnN0YXR1cyA9ICd3YWxsJztcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RUb0FuaW1hdGUucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1hemUucHJvdG90eXBlLmxlbmd0aExhcmdlclRoYW5IZWlnaHQgPSBmdW5jdGlvbiAoc3RhcnRYLCBlbmRYLCBzdGFydFksIGVuZFkpIHtcbiAgICB2YXIgcmV0dXJuVmFsID0gZW5kWCAtIHN0YXJ0WCAtIChlbmRZIC0gc3RhcnRZKSA+IDA7XG4gICAgcmV0dXJuIHJldHVyblZhbDtcbn07XG5cbk1hemUucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsaXN0ID0gdGhpcy5saXN0VG9BbmltYXRlO1xuICAgIGZ1bmN0aW9uIHRpbWVvdXQoaW5kZXgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2FyZC5zaG91bGREaXNhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNlbGwgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNlbGwuaWQpLmNsYXNzTmFtZSA9IGNlbGwuc3RhdHVzO1xuICAgICAgICAgICAgdGltZW91dChpbmRleCArIDEpO1xuICAgICAgICB9LCAwLjAwMDEpO1xuICAgIH1cbiAgICB0aW1lb3V0KDApO1xufTtcblxuTWF6ZS5wcm90b3R5cGUuaW5zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMubGlzdFRvQW5pbWF0ZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMubGlzdFRvQW5pbWF0ZVtpXTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2VsbC5pZCkuY2xhc3NOYW1lID0gY2VsbC5zdGF0dXM7XG4gICAgfVxuICAgIHRoaXMuYm9hcmQuc2hvdWxkRGlzYWJsZSA9IGZhbHNlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTWF6ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9NYXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * JavaScript Program Modified By SOULEYMANE DEMBELE 09/23/2019\n */\nvar Search = function Search(board, startNode, finalNode, currentAlgorithm, boardA) {\n    _classCallCheck(this, Search);\n\n    this.currentAlgorithm = currentAlgorithm;\n    this.board = board;\n    this.startNode = startNode;\n    this.finalNode = finalNode;\n    this.boardA = boardA;\n};\n\nSearch.prototype.startSearch = function () {\n    this.boardA.shouldDisable = true;\n    this.boardA.changeToRed();\n    document.getElementById(this.finalNode.id).className = 'finalCell';\n    this.finalNode.className = 'finalCell';\n    if (this.currentAlgorithm === 'BFS') {\n        var exploredList = this.searchBFS();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'DFS') {\n        var exploredList = this.searchDFS();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'Dijkstra') {\n        var exploredList = this.searchDijkstra();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'AStar') {\n        var exploredList = this.searchAStar();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'AStar2') {\n        var exploredList = this.searchAStar('2');\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'Greedy') {\n        var exploredList = this.searchGreedy();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'RealAStar') {\n        var exploredList = this.searchRealAStaar();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    } else if (this.currentAlgorithm === 'Bidirectional') {\n        var exploredList = this.searchBidirectional();\n        this.boardA.algoDone === true ? this.showAnimationDrag(exploredList) : this.showAnimation(exploredList);\n    }\n};\n\nSearch.prototype.getNeighbours = function (arr, node, algo, exploredList) {\n    var neighbourList = [];\n    //Get Neighbour Up\n    if (node.y > 0 && arr[node.y - 1][node.x].status !== 'wall') {\n        var neighbour = arr[node.y - 1][node.x];\n\n        if (neighbour.parent === null || algo === 'DFS' && neighbour.status !== 'startNode' && exploredList.indexOf(neighbour) === -1) {\n            neighbour.parent = node;\n        }\n        neighbourList.push(neighbour);\n    }\n    //Get Neighbour Right\n    if (node.x < arr[0].length - 1 && arr[node.y][node.x + 1].status !== 'wall') {\n        var neighbour = arr[node.y][node.x + 1];\n        // console.log(neighbour.id,arr.finalNode)\n        if (neighbour.parent === null || algo === 'DFS' && neighbour.status !== 'startNode' && exploredList.indexOf(neighbour) === -1) {\n            neighbour.parent = node;\n        }\n        neighbourList.push(neighbour);\n    }\n    //Get Neighbour Down\n    if (node.y < arr.length - 1 && arr[node.y + 1][node.x].status !== 'wall') {\n        var neighbour = arr[node.y + 1][node.x];\n        if (neighbour.parent === null || algo === 'DFS' && neighbour.status !== 'startNode' && exploredList.indexOf(neighbour) === -1) {\n            neighbour.parent = node;\n        }\n        neighbourList.push(neighbour);\n    }\n    //Get Neighbour Left\n    if (node.x > 0 && arr[node.y][node.x - 1].status !== 'wall') {\n        var neighbour = arr[node.y][node.x - 1];\n        if (neighbour.parent === null || algo === 'DFS' && neighbour.status !== 'startNode' && exploredList.indexOf(neighbour) === -1) {\n            neighbour.parent = node;\n        }\n        neighbourList.push(neighbour);\n    }\n    return neighbourList;\n};\n\nSearch.prototype.searchDFS = function () {\n    var exploredList = [];\n    var listToExplore = [this.startNode];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        var currentNode = listToExplore[0];\n        if (currentNode === this.finalNode) {\n            currentNode.status = 'finalNode';\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            var neighbours = this.getNeighbours(this.board, currentNode, 'DFS', exploredList);\n            listToExplore = listToExplore.slice(1);\n            listToExplore = neighbours.concat(listToExplore);\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    this.boardA.currentAlgo = 'DFS';\n    return exploredList;\n};\n\nSearch.prototype.searchBFS = function () {\n    var exploredList = [];\n    var numOnes = 0;\n    var listToExplore = [this.startNode];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        var currentNode = listToExplore[0];\n        var inWhileLoop = new Date();\n        if (currentNode === this.finalNode) {\n            // currentNode.status = 'finalNode'\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            var neighbours = this.getNeighbours(this.board, currentNode);\n            listToExplore = listToExplore.slice(1);\n            listToExplore = listToExplore.concat(neighbours);\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    this.boardA.currentAlgo = 'BFS';\n    return exploredList;\n};\n\nSearch.prototype.searchBidirectional = function () {\n    this.startNode.distance = 0;\n    this.finalNode.distance = 0;\n    var exploredList = [];\n    var listToExploreStart = [this.startNode];\n    var listToExploreFinal = [this.finalNode];\n    var numOnes = 0;\n    var count = 2;\n    var currentNode;\n    var status;\n    var pleaseWork = function pleaseWork(node, status) {\n        var returnVal = false;\n        for (var i in exploredList) {\n            if (i < exploredList.length - 1 && exploredList[i].id === node.id && exploredList[i].exploredBy !== status) {\n                // console.log(exploredList[i].id,node.id,status,exploredList[i].exploredBy)\n                returnVal = 'break';\n                break;\n            } else if (i < exploredList.length - 1 && exploredList[i].id === node.id && exploredList[i].exploredBy === status) {\n                // console.log(exploredList[i].id,node.id,status,exploredList[i].exploredBy)\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExploreStart.length !== 0 && listToExploreFinal.length !== 0) {\n        //Check which list to use currentNode from\n        // console.log(listToExploreStart.length+listToExploreFinal.length)\n        listToExploreStart = listToExploreStart.sort(function (nodeA, nodeB) {\n            return nodeA.distance - nodeB.distance;\n        });\n        listToExploreFinal = listToExploreFinal.sort(function (nodeA, nodeB) {\n            return nodeA.distance - nodeB.distance;\n        });\n        currentNode = count % 2 === 0 ? listToExploreStart[0] : listToExploreFinal[0];\n        // console.log(currentNode)\n        count % 2 === 0 ? status = 'start' : status = 'final';\n        var value = pleaseWork(currentNode, status);\n        // console.log(value)\n        if (value === 'break') {\n            console.log(\"breaking whileLoop\");\n            break whileLoop;\n        }\n        //Wall\n        if (currentNode.status === 'wall') {\n            count % 2 === 0 ? listToExploreStart = listToExploreStart.slice(1) : listToExploreFinal = listToExploreFinal.slice(1);\n        } else if (value === false) {\n            //Get neighbours\n            var neighbours;\n            count % 2 === 0 ? neighbours = this.getNeighboursAStar(this.board, currentNode, exploredList, 'algo', this.finalNode) : neighbours = this.getNeighboursAStar(this.board, currentNode, exploredList, 'algo', this.startNode);\n            // var neighbours = this.getNeighbours(this.board,currentNode)\n            //Remove node from listToExplore\n            if (count % 2 === 0) {\n                listToExploreStart = listToExploreStart.slice(1);\n            } else {\n                listToExploreFinal = listToExploreFinal.slice(1);\n            }\n\n            if (count % 2 === 0) {\n                var newNeighboursList = [];\n                for (var i in neighbours) {\n                    neighbours[i].exploredBy = 'start';\n                    // console.log(neighbours[i])\n                    newNeighboursList.push(neighbours[i]);\n                }\n                listToExploreStart = listToExploreStart.concat(newNeighboursList);\n            } else {\n                var newNeighboursList = [];\n                for (var i in neighbours) {\n                    neighbours[i].exploredBy = 'final';\n                    // console.log(neighbours[i])\n                    newNeighboursList.push(neighbours[i]);\n                }\n                listToExploreFinal = listToExploreFinal.concat(newNeighboursList);\n            }\n            ++count;\n            if (count < 5) {\n                console.log(exploredList);\n            }\n            exploredList.push(currentNode);\n        } else {\n            count % 2 === 0 ? listToExploreStart = listToExploreStart.slice(1) : listToExploreFinal = listToExploreFinal.slice(1);\n        }\n        // ++count\n    }\n    return exploredList;\n};\n\nSearch.prototype.searchBidirectional2 = function () {};\n\nSearch.prototype.searchAStar = function (algo) {\n    this.startNode.distance = 0;\n    var listToExplore = [this.startNode];\n    var exploredList = [];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        //Sort listToExplore by distance\n        listToExplore = listToExplore.sort(function (nodeA, nodeB) {\n            return nodeA.distance - nodeB.distance;\n        });\n        //Get currentNode\n        var currentNode = listToExplore[0];\n\n        if (currentNode === this.finalNode) {\n            currentNode.status = 'finalNode';\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            //If currentNode is finalNode break\n            if (currentNode === this.finalNode) {\n                break whileLoop;\n            }\n            //Get currentNode's neighbours\n            var neighbours = this.getNeighboursAStar(this.board, currentNode, exploredList, algo, this.finalNode);\n            //Add neighbours to listToExplore\n            listToExplore = listToExplore.concat(neighbours);\n            //Remove currentNode from listToExplore\n            listToExplore = listToExplore.slice(1);\n            //Add currentNode to exploredList\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    algo === '2' ? this.boardA.currentAlgo = 'AStar2' : this.boardA.currentAlgo = 'AStar';\n    return exploredList;\n};\n\nSearch.prototype.searchGreedy = function () {\n    this.startNode.distance = 0;\n    var listToExplore = [this.startNode];\n    var exploredList = [];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        //Sort listToExplore by distance\n        listToExplore = listToExplore.sort(function (nodeA, nodeB) {\n            return nodeA.distance - nodeB.distance;\n        });\n        //Get currentNode\n        var currentNode = listToExplore[0];\n\n        if (currentNode === this.finalNode) {\n            currentNode.status = 'finalNode';\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            //If currentNode is finalNode break\n            if (currentNode === this.finalNode) {\n                break whileLoop;\n            }\n            //Get currentNode's neighbours\n            var neighbours = this.getNeighboursGreedy(this.board, currentNode, exploredList);\n            //Add neighbours to listToExplore\n            listToExplore = listToExplore.concat(neighbours);\n            //Remove currentNode from listToExplore\n            listToExplore = listToExplore.slice(1);\n            //Add currentNode to exploredList\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    this.boardA.currentAlgo = 'Greedy';\n    return exploredList;\n};\n\nSearch.prototype.showAnimation = function (exploredList) {\n    // for(var i in exploredList){console.log(exploredList[i].status,exploredList[i].weight)}\n    var count = 0;\n    var self = this;\n    var startNode = exploredList[0];\n    exploredList = exploredList.slice(1);\n    var endNode = exploredList[exploredList.length - 1];\n    function timeout(index, exploredList, timeLength) {\n        setTimeout(function () {\n            if (index === exploredList.length) {\n                if (count === 0) showPath(endNode, self);else {\n                    self.boardA.shouldDisable = false;\n                    self.boardA.changeFromRed();\n                    self.algoDone();\n                }\n                return;\n            }\n            change(exploredList[index], index, exploredList.length);\n            timeout(index + 1, exploredList, timeLength);\n        }, timeLength);\n    }\n    function change(node, index, length) {\n        var elem = document.getElementById(node.id);\n        if (node.status === 'unexplored weight') {\n            node.status = 'explored weight';\n            elem.className = 'explored weight';\n        } else if (node.status === 'unexplored') {\n            node.status = 'explored';\n            elem.className = 'explored';\n        } else if (node.status === 'shortestPath explored weight') {\n            elem.className = 'shortestPath explored weight';\n            if (node.parent.status === 'shortestPath') document.getElementById(node.parent.id).className = 'shortestPath';\n            if (index === length - 1) self.changeFinalClassName();\n        } else if (node.status === 'shortestPath') {\n            if (node.parent.status !== 'startNode') {\n                if (node.parent.status === 'shortestPath') document.getElementById(node.parent.id).className = 'shortestPath';\n                if (index !== length - 1) {\n                    var newClassName = 'shortestPath';\n                    if (self.currentAlgorithm !== 'BFS' && self.currentAlgorithm !== 'DFS') {\n                        newClassName += node.direction;\n                    } else {\n                        newClassName += 'NODIRECTION';\n                    }\n                    console.log(newClassName);\n                    document.getElementById(node.id).className = newClassName;\n                } else {\n                    document.getElementById(node.id).className = 'shortestPath';\n                    self.changeFinalClassName();\n                }\n            } else {\n                document.getElementById(node.parent.id).className = 'startingCell shortestPath';\n                node.status = 'shortestPath';\n                if (self.finalNode.parent === node) {\n                    document.getElementById(node.id).className = 'shortestPath' + node.direction;\n                    self.changeFinalClassName(node);\n                }\n            }\n        }\n    }\n    function showPath(node, search) {\n        count++;\n        var listPath = [];\n        var endNode = Object.assign({}, node);\n        while (node !== startNode) {\n            if (node.status !== endNode.status) {\n                listPath.push(node);\n            }\n            node = node.parent;\n        }\n        if (endNode.status === self.finalNode.status) {\n            listPath.forEach(function (e) {\n                e.status === 'explored weight' ? e.status = 'shortestPath explored weight' : e.status = 'shortestPath';\n            });\n            timeout(0, listPath.reverse(), 35);\n        } else {\n            self.boardA.shouldDisable = false;\n        }\n    }\n    timeout(0, exploredList, 0.001);\n};\n\nSearch.prototype.algoDone = function () {\n    this.boardA.algoDone = true;\n};\n\nSearch.prototype.changeFinalClassName = function (node) {\n    if (node) document.getElementById(node.id).className = 'shortestPath';\n    var finalCell;\n    finalCell = document.getElementsByClassName('finalCell')[1];\n    if (!finalCell) finalCell = document.getElementsByClassName('finalCellUP')[0];\n    if (!finalCell) finalCell = document.getElementsByClassName('finalCellRIGHT')[0];\n    if (!finalCell) finalCell = document.getElementsByClassName('finalCellDOWN')[0];\n    if (!finalCell) finalCell = document.getElementsByClassName('finalCellLEFT')[0];\n    if (this.currentAlgorithm !== 'BFS' && this.currentAlgorithm !== 'DFS') {\n        finalCell.className = 'finalCell' + this.finalNode.direction;\n    } else {\n        finalCell.className = 'finalCell' + 'NODIRECTION';\n    }\n};\n\nSearch.prototype.changeFirstClassName = function () {\n    document.getElementById(this.startNode.id).className = 'startingCell shortestPath';\n};\n\nSearch.prototype.showAnimationDrag = function (exploredList) {\n    for (var i in exploredList) {\n        var cell = exploredList[i];\n        if (cell.status === 'unexplored') {\n            cell.status = 'explored';\n            document.getElementById(cell.id).className = 'explored';\n        } else if (cell.status === 'unexplored weight') {\n            cell.status = 'explored weight';\n            document.getElementById(cell.id).className = 'explored weight';\n        }\n    }\n    var endNode = exploredList[exploredList.length - 1];\n    var newEndNode = Object.assign({}, endNode);\n    var shortestPathList = [];\n    while (endNode !== this.startNode) {\n        shortestPathList.push(endNode);\n        endNode = endNode.parent;\n    }\n    shortestPathList = shortestPathList.reverse();\n    if (newEndNode.status === 'finalNode') {\n        this.changeFirstClassName();\n        this.changeFinalClassName();\n        for (var i in shortestPathList) {\n            var cell = shortestPathList[i];\n            if (cell.status === 'explored weight') {\n                cell.status = 'shortestPath explored weight';\n                document.getElementById(cell.id).className = 'shortestPath explored weight';\n            } else if (cell.status !== 'startNode' && cell.status !== 'finalNode') {\n                cell.status = 'explored';\n                document.getElementById(cell.id).className = 'shortestPath';\n            }\n        }\n    }\n    this.boardA.shouldDisable = false;\n    this.boardA.changeFromRed();\n    this.boardA.algoDone = true;\n};\n\nSearch.prototype.getNeighboursDijkstra = function (arr, node, exploredList) {\n    var neigbourList = [];\n    //Up\n    if (node.y > 0 && arr[node.y - 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y - 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y - 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'UP');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + neighbour.weight;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'UP';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Right\n    if (node.x < arr[0].length - 1 && arr[node.y][node.x + 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x + 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x + 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'RIGHT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + neighbour.weight;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'RIGHT';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Down\n    if (node.y < arr.length - 1 && arr[node.y + 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y + 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y + 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'DOWN');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + neighbour.weight;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'DOWN';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Left\n    if (node.x > 0 && arr[node.y][node.x - 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x - 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x - 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'LEFT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + neighbour.weight;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'LEFT';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    return neigbourList;\n};\n\nSearch.prototype.getNeighboursAStar = function (arr, node, exploredList, algo, finalNode) {\n    var neigbourList = [];\n    //Up\n    if (node.y > 0 && arr[node.y - 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y - 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y - 1][node.x];\n        // console.log('neighbour',neighbour.distance)\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'UP');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + this.manhattanDistance(neighbour, finalNode) + neighbour.weight;\n        var newNeighbourDistance2 = currentDistance + numberOfMoves + 1 + Math.pow(this.manhattanDistance(neighbour, finalNode), 6) + neighbour.weight;\n        algo === '2' ? newNeighbourDistance = newNeighbourDistance2 : newNeighbourDistance;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            // console.log(\"here\")\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'UP';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Right\n    if (node.x < arr[0].length - 1 && arr[node.y][node.x + 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x + 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x + 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'RIGHT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + this.manhattanDistance(neighbour, finalNode) + neighbour.weight;\n        var newNeighbourDistance2 = currentDistance + numberOfMoves + 1 + Math.pow(this.manhattanDistance(neighbour, finalNode), 6) + neighbour.weight;\n        algo === '2' ? newNeighbourDistance = newNeighbourDistance2 : newNeighbourDistance;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'RIGHT';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Down\n    if (node.y < arr.length - 1 && arr[node.y + 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y + 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y + 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'DOWN');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + this.manhattanDistance(neighbour, finalNode) + neighbour.weight;\n        var newNeighbourDistance2 = currentDistance + numberOfMoves + 1 + Math.pow(this.manhattanDistance(neighbour, finalNode), 6) + neighbour.weight;\n        algo === '2' ? newNeighbourDistance = newNeighbourDistance2 : newNeighbourDistance;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'DOWN';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Left\n    if (node.x > 0 && arr[node.y][node.x - 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x - 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x - 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'LEFT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = currentDistance + numberOfMoves + 1 + this.manhattanDistance(neighbour, finalNode) + neighbour.weight;\n        var newNeighbourDistance2 = currentDistance + numberOfMoves + 1 + Math.pow(this.manhattanDistance(neighbour, finalNode), 6) + neighbour.weight;\n        algo === '2' ? newNeighbourDistance = newNeighbourDistance2 : newNeighbourDistance;\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'LEFT';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    return neigbourList;\n};\n\nSearch.prototype.getNeighboursGreedy = function (arr, node, exploredList) {\n    var neigbourList = [];\n    //Up\n    if (node.y > 0 && arr[node.y - 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y - 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y - 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'UP');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'UP';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Right\n    if (node.x < arr[0].length - 1 && arr[node.y][node.x + 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x + 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x + 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'RIGHT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'RIGHT';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Down\n    if (node.y < arr.length - 1 && arr[node.y + 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y + 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y + 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'DOWN');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'DOWN';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Left\n    if (node.x > 0 && arr[node.y][node.x - 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x - 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x - 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'LEFT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'LEFT';\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    return neigbourList;\n};\n\nSearch.prototype.searchDijkstra = function () {\n    this.startNode.distance = 0;\n    var listToExplore = [this.startNode];\n    var exploredList = [];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        //Sort listToExplore by distance\n        listToExplore = listToExplore.sort(function (nodeA, nodeB) {\n            return nodeA.distance - nodeB.distance;\n        });\n        //Get currentNode\n        var currentNode = listToExplore[0];\n\n        if (currentNode === this.finalNode) {\n            currentNode.status = 'finalNode';\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            //If currentNode is finalNode break\n            if (currentNode === this.finalNode) {\n                break whileLoop;\n            }\n            //Get currentNode's neighbours\n            var neighbours = this.getNeighboursDijkstra(this.board, currentNode, exploredList);\n            //Add neighbours to listToExplore\n            listToExplore = listToExplore.concat(neighbours);\n            //Remove currentNode from listToExplore\n            listToExplore = listToExplore.slice(1);\n            //Add currentNode to exploredList\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    this.boardA.currentAlgo = 'Dijkstra';\n\n    return exploredList;\n};\n\nSearch.prototype.hasBeenExplored = function (node, exploredList) {\n    var returnVal = false;\n    for (var i in exploredList.length) {\n        if (exploredList[i].id === node.id) {\n            returnVal = true;\n        }\n    }\n    return returnVal;\n};\n\nSearch.prototype.checkNumberOfMoves = function (currentDirection, direction) {\n    if (currentDirection === direction) {\n        return 0;\n    } else if ((currentDirection === 'UP' || currentDirection === 'DOWN') && (direction === 'LEFT' || direction === 'RIGHT')) {\n        return 1;\n    } else if ((currentDirection === 'LEFT' || currentDirection === 'RIGHT') && (direction === 'UP' || direction === 'DOWN')) {\n        return 1;\n    } else if ((currentDirection === 'LEFT' || currentDirection === 'RIGHT') && (direction === 'LEFT' || direction === 'RIGHT')) {\n        return 2;\n    } else if ((currentDirection === 'UP' || currentDirection === 'DOWN') && (direction === 'UP' || direction === 'DOWN')) {\n        return 2;\n    }\n};\n\nSearch.prototype.manhattanDistance = function (node1, node2) {\n    var xDiff = Math.abs(node1.x - node2.x);\n    var yDiff = Math.abs(node1.y - node2.y);\n    var distance = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));\n    var sum = xDiff + yDiff;\n    return sum;\n};\n\nSearch.prototype.realAStar = function () {\n    this.startNode.distance = 0;\n    this.startNode.heuristicDistance = this.manhattanDistance(this.startNode, this.finalNode);\n    this.startNode.totalDistance = this.startNode.distance + this.startNode.heuristicDistance;\n    var listToExplore = [this.startNode];\n    var exploredList = [];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        //Sort listToExplore by distance\n        listToExplore = listToExplore.sort(function (nodeA, nodeB) {\n            return nodeA.totalDistance + nodeA.heuristicDistance - (nodeB.totalDistance + nodeB.heuristicDistance);\n        });\n        //Get currentNode\n        var currentNode = listToExplore[0];\n\n        if (currentNode === this.finalNode) {\n            currentNode.status = 'finalNode';\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            //If currentNode is finalNode break\n            if (currentNode === this.finalNode) {\n                break whileLoop;\n            }\n            //Get currentNode's neighbours\n            var neighbours = this.getNeighboursRealAStar(this.board, currentNode, exploredList);\n            //Add neighbours to listToExplore\n            listToExplore = listToExplore.concat(neighbours);\n            //Remove currentNode from listToExplore\n            listToExplore = listToExplore.slice(1);\n            //Add currentNode to exploredList\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    this.boardA.currentAlgo = 'RealAStar';\n    return exploredList;\n};\n\nSearch.prototype.getNeighboursRealAStar = function (arr, node, exploredList) {\n    var self = this;\n    var list = this.getNeighboursDijkstra(arr, node, exploredList);\n    list.forEach(function (neighbour) {\n        neighbour.heuristicDistance = self.manhattanDistance(neighbour, self.finalNode);\n        neighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\n        console.log(neighbour);\n    });\n    return list;\n};\n\nSearch.prototype.searchRealAStaar = function () {\n    this.startNode.distance = 0;\n    this.startNode.heuristicDistance = this.manhattanDistance(this.startNode, this.finalNode);\n    this.startNode.totalDistance = this.startNode.distance + this.startNode.heuristicDistance;\n    var listToExplore = [this.startNode];\n    var exploredList = [];\n    var isPresent = function isPresent(node) {\n        var returnVal = false;\n        for (var i = 0; i < exploredList.length; i++) {\n            if (exploredList[i].id === node.id) {\n                returnVal = true;\n            }\n        }\n        return returnVal;\n    };\n    whileLoop: while (listToExplore.length !== 0) {\n        //Sort listToExplore by distance\n        listToExplore = listToExplore.sort(function (nodeA, nodeB) {\n            if (nodeA.totalDistance === nodeB.totalDistance) {\n                return nodeA.heuristicDistance - nodeB.heuristicDistance;\n            }\n            return nodeA.totalDistance - nodeB.totalDistance;\n        });\n        //Get currentNode\n        var currentNode = listToExplore[0];\n\n        if (currentNode === this.finalNode) {\n            currentNode.status = 'finalNode';\n            exploredList.push(currentNode);\n            break whileLoop;\n        }\n        if (currentNode.status === 'wall') {\n            listToExplore = listToExplore.slice(1);\n        } else if (!isPresent(currentNode)) {\n            //If currentNode is finalNode break\n            if (currentNode === this.finalNode) {\n                break whileLoop;\n            }\n            //Get currentNode's neighbours\n            var neighbours = this.getNeighboursRealAStaar(this.board, currentNode, exploredList);\n            //Add neighbours to listToExplore\n            listToExplore = listToExplore.concat(neighbours);\n            //Remove currentNode from listToExplore\n            listToExplore = listToExplore.slice(1);\n            //Add currentNode to exploredList\n            exploredList.push(currentNode);\n        } else {\n            listToExplore = listToExplore.slice(1);\n        }\n    }\n    this.boardA.currentAlgo = 'RealAStar';\n\n    return exploredList;\n};\n\nSearch.prototype.getNeighboursRealAStaar = function (arr, node, exploredList) {\n    var neigbourList = [];\n    //Up\n    if (node.y > 0 && arr[node.y - 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y - 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y - 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'UP');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = node.distance + 1 + numberOfMoves + neighbour.weight;\n        neighbour.heuristicDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'UP';\n            neighbour.totalDistance = neighbour.heuristicDistance + neighbour.distance;\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Right\n    if (node.x < arr[0].length - 1 && arr[node.y][node.x + 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x + 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x + 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'RIGHT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = node.distance + 1 + numberOfMoves + neighbour.weight;\n        neighbour.heuristicDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'RIGHT';\n            neighbour.totalDistance = neighbour.heuristicDistance + neighbour.distance;\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Down\n    if (node.y < arr.length - 1 && arr[node.y + 1][node.x].status !== 'wall' && this.hasBeenExplored(arr[node.y + 1][node.x], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y + 1][node.x];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'DOWN');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = node.distance + 1 + numberOfMoves + neighbour.weight;\n        neighbour.heuristicDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'DOWN';\n            neighbour.totalDistance = neighbour.heuristicDistance + neighbour.distance;\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    //Left\n    if (node.x > 0 && arr[node.y][node.x - 1].status !== 'wall' && this.hasBeenExplored(arr[node.y][node.x - 1], exploredList) === false) {\n        //Get Up neighbour\n        var neighbour = arr[node.y][node.x - 1];\n        //Get current distance\n        var currentDistance = node.distance;\n        //Get My Direction\n        var myDirection = node.direction;\n        //Calculate number of moves to get to Get to Up Direction\n        var numberOfMoves = this.checkNumberOfMoves(myDirection, 'LEFT');\n        //Calculate new neighbour distance\n        var newNeighbourDistance = node.distance + 1 + numberOfMoves + neighbour.weight;\n        neighbour.heuristicDistance = this.manhattanDistance(neighbour, this.finalNode);\n        //If this is lower than the currentDistance on the neighbour change\n        if (newNeighbourDistance < neighbour.distance) {\n            neighbour.distance = newNeighbourDistance;\n            neighbour.direction = 'LEFT';\n            neighbour.totalDistance = neighbour.heuristicDistance + neighbour.distance;\n            //Add neighbour to neigbourList\n            neigbourList.push(neighbour);\n            neighbour.parent = node;\n        }\n    }\n    return neigbourList;\n};\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9TZWFyY2guanM/MDIwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBKYXZhU2NyaXB0IFByb2dyYW0gTW9kaWZpZWQgQnkgU09VTEVZTUFORSBERU1CRUxFIDA5LzIzLzIwMTlcbiAqL1xudmFyIFNlYXJjaCA9IGZ1bmN0aW9uIFNlYXJjaChib2FyZCwgc3RhcnROb2RlLCBmaW5hbE5vZGUsIGN1cnJlbnRBbGdvcml0aG0sIGJvYXJkQSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWFyY2gpO1xuXG4gICAgdGhpcy5jdXJyZW50QWxnb3JpdGhtID0gY3VycmVudEFsZ29yaXRobTtcbiAgICB0aGlzLmJvYXJkID0gYm9hcmQ7XG4gICAgdGhpcy5zdGFydE5vZGUgPSBzdGFydE5vZGU7XG4gICAgdGhpcy5maW5hbE5vZGUgPSBmaW5hbE5vZGU7XG4gICAgdGhpcy5ib2FyZEEgPSBib2FyZEE7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnN0YXJ0U2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYm9hcmRBLnNob3VsZERpc2FibGUgPSB0cnVlO1xuICAgIHRoaXMuYm9hcmRBLmNoYW5nZVRvUmVkKCk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5maW5hbE5vZGUuaWQpLmNsYXNzTmFtZSA9ICdmaW5hbENlbGwnO1xuICAgIHRoaXMuZmluYWxOb2RlLmNsYXNzTmFtZSA9ICdmaW5hbENlbGwnO1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbGdvcml0aG0gPT09ICdCRlMnKSB7XG4gICAgICAgIHZhciBleHBsb3JlZExpc3QgPSB0aGlzLnNlYXJjaEJGUygpO1xuICAgICAgICB0aGlzLmJvYXJkQS5hbGdvRG9uZSA9PT0gdHJ1ZSA/IHRoaXMuc2hvd0FuaW1hdGlvbkRyYWcoZXhwbG9yZWRMaXN0KSA6IHRoaXMuc2hvd0FuaW1hdGlvbihleHBsb3JlZExpc3QpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50QWxnb3JpdGhtID09PSAnREZTJykge1xuICAgICAgICB2YXIgZXhwbG9yZWRMaXN0ID0gdGhpcy5zZWFyY2hERlMoKTtcbiAgICAgICAgdGhpcy5ib2FyZEEuYWxnb0RvbmUgPT09IHRydWUgPyB0aGlzLnNob3dBbmltYXRpb25EcmFnKGV4cGxvcmVkTGlzdCkgOiB0aGlzLnNob3dBbmltYXRpb24oZXhwbG9yZWRMaXN0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudEFsZ29yaXRobSA9PT0gJ0RpamtzdHJhJykge1xuICAgICAgICB2YXIgZXhwbG9yZWRMaXN0ID0gdGhpcy5zZWFyY2hEaWprc3RyYSgpO1xuICAgICAgICB0aGlzLmJvYXJkQS5hbGdvRG9uZSA9PT0gdHJ1ZSA/IHRoaXMuc2hvd0FuaW1hdGlvbkRyYWcoZXhwbG9yZWRMaXN0KSA6IHRoaXMuc2hvd0FuaW1hdGlvbihleHBsb3JlZExpc3QpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50QWxnb3JpdGhtID09PSAnQVN0YXInKSB7XG4gICAgICAgIHZhciBleHBsb3JlZExpc3QgPSB0aGlzLnNlYXJjaEFTdGFyKCk7XG4gICAgICAgIHRoaXMuYm9hcmRBLmFsZ29Eb25lID09PSB0cnVlID8gdGhpcy5zaG93QW5pbWF0aW9uRHJhZyhleHBsb3JlZExpc3QpIDogdGhpcy5zaG93QW5pbWF0aW9uKGV4cGxvcmVkTGlzdCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRBbGdvcml0aG0gPT09ICdBU3RhcjInKSB7XG4gICAgICAgIHZhciBleHBsb3JlZExpc3QgPSB0aGlzLnNlYXJjaEFTdGFyKCcyJyk7XG4gICAgICAgIHRoaXMuYm9hcmRBLmFsZ29Eb25lID09PSB0cnVlID8gdGhpcy5zaG93QW5pbWF0aW9uRHJhZyhleHBsb3JlZExpc3QpIDogdGhpcy5zaG93QW5pbWF0aW9uKGV4cGxvcmVkTGlzdCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRBbGdvcml0aG0gPT09ICdHcmVlZHknKSB7XG4gICAgICAgIHZhciBleHBsb3JlZExpc3QgPSB0aGlzLnNlYXJjaEdyZWVkeSgpO1xuICAgICAgICB0aGlzLmJvYXJkQS5hbGdvRG9uZSA9PT0gdHJ1ZSA/IHRoaXMuc2hvd0FuaW1hdGlvbkRyYWcoZXhwbG9yZWRMaXN0KSA6IHRoaXMuc2hvd0FuaW1hdGlvbihleHBsb3JlZExpc3QpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50QWxnb3JpdGhtID09PSAnUmVhbEFTdGFyJykge1xuICAgICAgICB2YXIgZXhwbG9yZWRMaXN0ID0gdGhpcy5zZWFyY2hSZWFsQVN0YWFyKCk7XG4gICAgICAgIHRoaXMuYm9hcmRBLmFsZ29Eb25lID09PSB0cnVlID8gdGhpcy5zaG93QW5pbWF0aW9uRHJhZyhleHBsb3JlZExpc3QpIDogdGhpcy5zaG93QW5pbWF0aW9uKGV4cGxvcmVkTGlzdCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRBbGdvcml0aG0gPT09ICdCaWRpcmVjdGlvbmFsJykge1xuICAgICAgICB2YXIgZXhwbG9yZWRMaXN0ID0gdGhpcy5zZWFyY2hCaWRpcmVjdGlvbmFsKCk7XG4gICAgICAgIHRoaXMuYm9hcmRBLmFsZ29Eb25lID09PSB0cnVlID8gdGhpcy5zaG93QW5pbWF0aW9uRHJhZyhleHBsb3JlZExpc3QpIDogdGhpcy5zaG93QW5pbWF0aW9uKGV4cGxvcmVkTGlzdCk7XG4gICAgfVxufTtcblxuU2VhcmNoLnByb3RvdHlwZS5nZXROZWlnaGJvdXJzID0gZnVuY3Rpb24gKGFyciwgbm9kZSwgYWxnbywgZXhwbG9yZWRMaXN0KSB7XG4gICAgdmFyIG5laWdoYm91ckxpc3QgPSBbXTtcbiAgICAvL0dldCBOZWlnaGJvdXIgVXBcbiAgICBpZiAobm9kZS55ID4gMCAmJiBhcnJbbm9kZS55IC0gMV1bbm9kZS54XS5zdGF0dXMgIT09ICd3YWxsJykge1xuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueSAtIDFdW25vZGUueF07XG5cbiAgICAgICAgaWYgKG5laWdoYm91ci5wYXJlbnQgPT09IG51bGwgfHwgYWxnbyA9PT0gJ0RGUycgJiYgbmVpZ2hib3VyLnN0YXR1cyAhPT0gJ3N0YXJ0Tm9kZScgJiYgZXhwbG9yZWRMaXN0LmluZGV4T2YobmVpZ2hib3VyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5laWdoYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgIH1cbiAgICAvL0dldCBOZWlnaGJvdXIgUmlnaHRcbiAgICBpZiAobm9kZS54IDwgYXJyWzBdLmxlbmd0aCAtIDEgJiYgYXJyW25vZGUueV1bbm9kZS54ICsgMV0uc3RhdHVzICE9PSAnd2FsbCcpIHtcbiAgICAgICAgdmFyIG5laWdoYm91ciA9IGFycltub2RlLnldW25vZGUueCArIDFdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhuZWlnaGJvdXIuaWQsYXJyLmZpbmFsTm9kZSlcbiAgICAgICAgaWYgKG5laWdoYm91ci5wYXJlbnQgPT09IG51bGwgfHwgYWxnbyA9PT0gJ0RGUycgJiYgbmVpZ2hib3VyLnN0YXR1cyAhPT0gJ3N0YXJ0Tm9kZScgJiYgZXhwbG9yZWRMaXN0LmluZGV4T2YobmVpZ2hib3VyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5laWdoYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgIH1cbiAgICAvL0dldCBOZWlnaGJvdXIgRG93blxuICAgIGlmIChub2RlLnkgPCBhcnIubGVuZ3RoIC0gMSAmJiBhcnJbbm9kZS55ICsgMV1bbm9kZS54XS5zdGF0dXMgIT09ICd3YWxsJykge1xuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueSArIDFdW25vZGUueF07XG4gICAgICAgIGlmIChuZWlnaGJvdXIucGFyZW50ID09PSBudWxsIHx8IGFsZ28gPT09ICdERlMnICYmIG5laWdoYm91ci5zdGF0dXMgIT09ICdzdGFydE5vZGUnICYmIGV4cGxvcmVkTGlzdC5pbmRleE9mKG5laWdoYm91cikgPT09IC0xKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBuZWlnaGJvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICB9XG4gICAgLy9HZXQgTmVpZ2hib3VyIExlZnRcbiAgICBpZiAobm9kZS54ID4gMCAmJiBhcnJbbm9kZS55XVtub2RlLnggLSAxXS5zdGF0dXMgIT09ICd3YWxsJykge1xuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueV1bbm9kZS54IC0gMV07XG4gICAgICAgIGlmIChuZWlnaGJvdXIucGFyZW50ID09PSBudWxsIHx8IGFsZ28gPT09ICdERlMnICYmIG5laWdoYm91ci5zdGF0dXMgIT09ICdzdGFydE5vZGUnICYmIGV4cGxvcmVkTGlzdC5pbmRleE9mKG5laWdoYm91cikgPT09IC0xKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBuZWlnaGJvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5laWdoYm91ckxpc3Q7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnNlYXJjaERGUyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXhwbG9yZWRMaXN0ID0gW107XG4gICAgdmFyIGxpc3RUb0V4cGxvcmUgPSBbdGhpcy5zdGFydE5vZGVdO1xuICAgIHZhciBpc1ByZXNlbnQgPSBmdW5jdGlvbiBpc1ByZXNlbnQobm9kZSkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwbG9yZWRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwbG9yZWRMaXN0W2ldLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgIH07XG4gICAgd2hpbGVMb29wOiB3aGlsZSAobGlzdFRvRXhwbG9yZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGlzdFRvRXhwbG9yZVswXTtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmZpbmFsTm9kZSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc3RhdHVzID0gJ2ZpbmFsTm9kZSc7XG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBicmVhayB3aGlsZUxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnN0YXR1cyA9PT0gJ3dhbGwnKSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNQcmVzZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5laWdoYm91cnMgPSB0aGlzLmdldE5laWdoYm91cnModGhpcy5ib2FyZCwgY3VycmVudE5vZGUsICdERlMnLCBleHBsb3JlZExpc3QpO1xuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbmVpZ2hib3Vycy5jb25jYXQobGlzdFRvRXhwbG9yZSk7XG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJvYXJkQS5jdXJyZW50QWxnbyA9ICdERlMnO1xuICAgIHJldHVybiBleHBsb3JlZExpc3Q7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnNlYXJjaEJGUyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXhwbG9yZWRMaXN0ID0gW107XG4gICAgdmFyIG51bU9uZXMgPSAwO1xuICAgIHZhciBsaXN0VG9FeHBsb3JlID0gW3RoaXMuc3RhcnROb2RlXTtcbiAgICB2YXIgaXNQcmVzZW50ID0gZnVuY3Rpb24gaXNQcmVzZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGxvcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cGxvcmVkTGlzdFtpXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9O1xuICAgIHdoaWxlTG9vcDogd2hpbGUgKGxpc3RUb0V4cGxvcmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGxpc3RUb0V4cGxvcmVbMF07XG4gICAgICAgIHZhciBpbldoaWxlTG9vcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGhpcy5maW5hbE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGN1cnJlbnROb2RlLnN0YXR1cyA9ICdmaW5hbE5vZGUnXG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBicmVhayB3aGlsZUxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnN0YXR1cyA9PT0gJ3dhbGwnKSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNQcmVzZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5laWdoYm91cnMgPSB0aGlzLmdldE5laWdoYm91cnModGhpcy5ib2FyZCwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5jb25jYXQobmVpZ2hib3Vycyk7XG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJvYXJkQS5jdXJyZW50QWxnbyA9ICdCRlMnO1xuICAgIHJldHVybiBleHBsb3JlZExpc3Q7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnNlYXJjaEJpZGlyZWN0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGFydE5vZGUuZGlzdGFuY2UgPSAwO1xuICAgIHRoaXMuZmluYWxOb2RlLmRpc3RhbmNlID0gMDtcbiAgICB2YXIgZXhwbG9yZWRMaXN0ID0gW107XG4gICAgdmFyIGxpc3RUb0V4cGxvcmVTdGFydCA9IFt0aGlzLnN0YXJ0Tm9kZV07XG4gICAgdmFyIGxpc3RUb0V4cGxvcmVGaW5hbCA9IFt0aGlzLmZpbmFsTm9kZV07XG4gICAgdmFyIG51bU9uZXMgPSAwO1xuICAgIHZhciBjb3VudCA9IDI7XG4gICAgdmFyIGN1cnJlbnROb2RlO1xuICAgIHZhciBzdGF0dXM7XG4gICAgdmFyIHBsZWFzZVdvcmsgPSBmdW5jdGlvbiBwbGVhc2VXb3JrKG5vZGUsIHN0YXR1cykge1xuICAgICAgICB2YXIgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgaW4gZXhwbG9yZWRMaXN0KSB7XG4gICAgICAgICAgICBpZiAoaSA8IGV4cGxvcmVkTGlzdC5sZW5ndGggLSAxICYmIGV4cGxvcmVkTGlzdFtpXS5pZCA9PT0gbm9kZS5pZCAmJiBleHBsb3JlZExpc3RbaV0uZXhwbG9yZWRCeSAhPT0gc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXhwbG9yZWRMaXN0W2ldLmlkLG5vZGUuaWQsc3RhdHVzLGV4cGxvcmVkTGlzdFtpXS5leHBsb3JlZEJ5KVxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9ICdicmVhayc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCBleHBsb3JlZExpc3QubGVuZ3RoIC0gMSAmJiBleHBsb3JlZExpc3RbaV0uaWQgPT09IG5vZGUuaWQgJiYgZXhwbG9yZWRMaXN0W2ldLmV4cGxvcmVkQnkgPT09IHN0YXR1cykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGV4cGxvcmVkTGlzdFtpXS5pZCxub2RlLmlkLHN0YXR1cyxleHBsb3JlZExpc3RbaV0uZXhwbG9yZWRCeSlcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgfTtcbiAgICB3aGlsZUxvb3A6IHdoaWxlIChsaXN0VG9FeHBsb3JlU3RhcnQubGVuZ3RoICE9PSAwICYmIGxpc3RUb0V4cGxvcmVGaW5hbC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy9DaGVjayB3aGljaCBsaXN0IHRvIHVzZSBjdXJyZW50Tm9kZSBmcm9tXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGxpc3RUb0V4cGxvcmVTdGFydC5sZW5ndGgrbGlzdFRvRXhwbG9yZUZpbmFsLmxlbmd0aClcbiAgICAgICAgbGlzdFRvRXhwbG9yZVN0YXJ0ID0gbGlzdFRvRXhwbG9yZVN0YXJ0LnNvcnQoZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVBLmRpc3RhbmNlIC0gbm9kZUIuZGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0VG9FeHBsb3JlRmluYWwgPSBsaXN0VG9FeHBsb3JlRmluYWwuc29ydChmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUEuZGlzdGFuY2UgLSBub2RlQi5kaXN0YW5jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY291bnQgJSAyID09PSAwID8gbGlzdFRvRXhwbG9yZVN0YXJ0WzBdIDogbGlzdFRvRXhwbG9yZUZpbmFsWzBdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50Tm9kZSlcbiAgICAgICAgY291bnQgJSAyID09PSAwID8gc3RhdHVzID0gJ3N0YXJ0JyA6IHN0YXR1cyA9ICdmaW5hbCc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBsZWFzZVdvcmsoY3VycmVudE5vZGUsIHN0YXR1cyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlKVxuICAgICAgICBpZiAodmFsdWUgPT09ICdicmVhaycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYnJlYWtpbmcgd2hpbGVMb29wXCIpO1xuICAgICAgICAgICAgYnJlYWsgd2hpbGVMb29wO1xuICAgICAgICB9XG4gICAgICAgIC8vV2FsbFxuICAgICAgICBpZiAoY3VycmVudE5vZGUuc3RhdHVzID09PSAnd2FsbCcpIHtcbiAgICAgICAgICAgIGNvdW50ICUgMiA9PT0gMCA/IGxpc3RUb0V4cGxvcmVTdGFydCA9IGxpc3RUb0V4cGxvcmVTdGFydC5zbGljZSgxKSA6IGxpc3RUb0V4cGxvcmVGaW5hbCA9IGxpc3RUb0V4cGxvcmVGaW5hbC5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vR2V0IG5laWdoYm91cnNcbiAgICAgICAgICAgIHZhciBuZWlnaGJvdXJzO1xuICAgICAgICAgICAgY291bnQgJSAyID09PSAwID8gbmVpZ2hib3VycyA9IHRoaXMuZ2V0TmVpZ2hib3Vyc0FTdGFyKHRoaXMuYm9hcmQsIGN1cnJlbnROb2RlLCBleHBsb3JlZExpc3QsICdhbGdvJywgdGhpcy5maW5hbE5vZGUpIDogbmVpZ2hib3VycyA9IHRoaXMuZ2V0TmVpZ2hib3Vyc0FTdGFyKHRoaXMuYm9hcmQsIGN1cnJlbnROb2RlLCBleHBsb3JlZExpc3QsICdhbGdvJywgdGhpcy5zdGFydE5vZGUpO1xuICAgICAgICAgICAgLy8gdmFyIG5laWdoYm91cnMgPSB0aGlzLmdldE5laWdoYm91cnModGhpcy5ib2FyZCxjdXJyZW50Tm9kZSlcbiAgICAgICAgICAgIC8vUmVtb3ZlIG5vZGUgZnJvbSBsaXN0VG9FeHBsb3JlXG4gICAgICAgICAgICBpZiAoY291bnQgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGlzdFRvRXhwbG9yZVN0YXJ0ID0gbGlzdFRvRXhwbG9yZVN0YXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0VG9FeHBsb3JlRmluYWwgPSBsaXN0VG9FeHBsb3JlRmluYWwuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb3VudCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmVpZ2hib3Vyc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5laWdoYm91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3Vyc1tpXS5leHBsb3JlZEJ5ID0gJ3N0YXJ0JztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmVpZ2hib3Vyc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgbmV3TmVpZ2hib3Vyc0xpc3QucHVzaChuZWlnaGJvdXJzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdFRvRXhwbG9yZVN0YXJ0ID0gbGlzdFRvRXhwbG9yZVN0YXJ0LmNvbmNhdChuZXdOZWlnaGJvdXJzTGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOZWlnaGJvdXJzTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbmVpZ2hib3Vycykge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvdXJzW2ldLmV4cGxvcmVkQnkgPSAnZmluYWwnO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuZWlnaGJvdXJzW2ldKVxuICAgICAgICAgICAgICAgICAgICBuZXdOZWlnaGJvdXJzTGlzdC5wdXNoKG5laWdoYm91cnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0VG9FeHBsb3JlRmluYWwgPSBsaXN0VG9FeHBsb3JlRmluYWwuY29uY2F0KG5ld05laWdoYm91cnNMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICBpZiAoY291bnQgPCA1KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhwbG9yZWRMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGxvcmVkTGlzdC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ICUgMiA9PT0gMCA/IGxpc3RUb0V4cGxvcmVTdGFydCA9IGxpc3RUb0V4cGxvcmVTdGFydC5zbGljZSgxKSA6IGxpc3RUb0V4cGxvcmVGaW5hbCA9IGxpc3RUb0V4cGxvcmVGaW5hbC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyArK2NvdW50XG4gICAgfVxuICAgIHJldHVybiBleHBsb3JlZExpc3Q7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnNlYXJjaEJpZGlyZWN0aW9uYWwyID0gZnVuY3Rpb24gKCkge307XG5cblNlYXJjaC5wcm90b3R5cGUuc2VhcmNoQVN0YXIgPSBmdW5jdGlvbiAoYWxnbykge1xuICAgIHRoaXMuc3RhcnROb2RlLmRpc3RhbmNlID0gMDtcbiAgICB2YXIgbGlzdFRvRXhwbG9yZSA9IFt0aGlzLnN0YXJ0Tm9kZV07XG4gICAgdmFyIGV4cGxvcmVkTGlzdCA9IFtdO1xuICAgIHZhciBpc1ByZXNlbnQgPSBmdW5jdGlvbiBpc1ByZXNlbnQobm9kZSkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwbG9yZWRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwbG9yZWRMaXN0W2ldLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgIH07XG4gICAgd2hpbGVMb29wOiB3aGlsZSAobGlzdFRvRXhwbG9yZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy9Tb3J0IGxpc3RUb0V4cGxvcmUgYnkgZGlzdGFuY2VcbiAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc29ydChmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUEuZGlzdGFuY2UgLSBub2RlQi5kaXN0YW5jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vR2V0IGN1cnJlbnROb2RlXG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGxpc3RUb0V4cGxvcmVbMF07XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmZpbmFsTm9kZSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc3RhdHVzID0gJ2ZpbmFsTm9kZSc7XG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBicmVhayB3aGlsZUxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnN0YXR1cyA9PT0gJ3dhbGwnKSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNQcmVzZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgLy9JZiBjdXJyZW50Tm9kZSBpcyBmaW5hbE5vZGUgYnJlYWtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGhpcy5maW5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVhayB3aGlsZUxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0dldCBjdXJyZW50Tm9kZSdzIG5laWdoYm91cnNcbiAgICAgICAgICAgIHZhciBuZWlnaGJvdXJzID0gdGhpcy5nZXROZWlnaGJvdXJzQVN0YXIodGhpcy5ib2FyZCwgY3VycmVudE5vZGUsIGV4cGxvcmVkTGlzdCwgYWxnbywgdGhpcy5maW5hbE5vZGUpO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VycyB0byBsaXN0VG9FeHBsb3JlXG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5jb25jYXQobmVpZ2hib3Vycyk7XG4gICAgICAgICAgICAvL1JlbW92ZSBjdXJyZW50Tm9kZSBmcm9tIGxpc3RUb0V4cGxvcmVcbiAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNsaWNlKDEpO1xuICAgICAgICAgICAgLy9BZGQgY3VycmVudE5vZGUgdG8gZXhwbG9yZWRMaXN0XG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGdvID09PSAnMicgPyB0aGlzLmJvYXJkQS5jdXJyZW50QWxnbyA9ICdBU3RhcjInIDogdGhpcy5ib2FyZEEuY3VycmVudEFsZ28gPSAnQVN0YXInO1xuICAgIHJldHVybiBleHBsb3JlZExpc3Q7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnNlYXJjaEdyZWVkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YXJ0Tm9kZS5kaXN0YW5jZSA9IDA7XG4gICAgdmFyIGxpc3RUb0V4cGxvcmUgPSBbdGhpcy5zdGFydE5vZGVdO1xuICAgIHZhciBleHBsb3JlZExpc3QgPSBbXTtcbiAgICB2YXIgaXNQcmVzZW50ID0gZnVuY3Rpb24gaXNQcmVzZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGxvcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cGxvcmVkTGlzdFtpXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9O1xuICAgIHdoaWxlTG9vcDogd2hpbGUgKGxpc3RUb0V4cGxvcmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vU29ydCBsaXN0VG9FeHBsb3JlIGJ5IGRpc3RhbmNlXG4gICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNvcnQoZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVBLmRpc3RhbmNlIC0gbm9kZUIuZGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICAvL0dldCBjdXJyZW50Tm9kZVxuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBsaXN0VG9FeHBsb3JlWzBdO1xuXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGhpcy5maW5hbE5vZGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnN0YXR1cyA9ICdmaW5hbE5vZGUnO1xuICAgICAgICAgICAgZXhwbG9yZWRMaXN0LnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgYnJlYWsgd2hpbGVMb29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5zdGF0dXMgPT09ICd3YWxsJykge1xuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzUHJlc2VudChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vSWYgY3VycmVudE5vZGUgaXMgZmluYWxOb2RlIGJyZWFrXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMuZmluYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgd2hpbGVMb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9HZXQgY3VycmVudE5vZGUncyBuZWlnaGJvdXJzXG4gICAgICAgICAgICB2YXIgbmVpZ2hib3VycyA9IHRoaXMuZ2V0TmVpZ2hib3Vyc0dyZWVkeSh0aGlzLmJvYXJkLCBjdXJyZW50Tm9kZSwgZXhwbG9yZWRMaXN0KTtcbiAgICAgICAgICAgIC8vQWRkIG5laWdoYm91cnMgdG8gbGlzdFRvRXhwbG9yZVxuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuY29uY2F0KG5laWdoYm91cnMpO1xuICAgICAgICAgICAgLy9SZW1vdmUgY3VycmVudE5vZGUgZnJvbSBsaXN0VG9FeHBsb3JlXG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vQWRkIGN1cnJlbnROb2RlIHRvIGV4cGxvcmVkTGlzdFxuICAgICAgICAgICAgZXhwbG9yZWRMaXN0LnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ib2FyZEEuY3VycmVudEFsZ28gPSAnR3JlZWR5JztcbiAgICByZXR1cm4gZXhwbG9yZWRMaXN0O1xufTtcblxuU2VhcmNoLnByb3RvdHlwZS5zaG93QW5pbWF0aW9uID0gZnVuY3Rpb24gKGV4cGxvcmVkTGlzdCkge1xuICAgIC8vIGZvcih2YXIgaSBpbiBleHBsb3JlZExpc3Qpe2NvbnNvbGUubG9nKGV4cGxvcmVkTGlzdFtpXS5zdGF0dXMsZXhwbG9yZWRMaXN0W2ldLndlaWdodCl9XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YXJ0Tm9kZSA9IGV4cGxvcmVkTGlzdFswXTtcbiAgICBleHBsb3JlZExpc3QgPSBleHBsb3JlZExpc3Quc2xpY2UoMSk7XG4gICAgdmFyIGVuZE5vZGUgPSBleHBsb3JlZExpc3RbZXhwbG9yZWRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIGZ1bmN0aW9uIHRpbWVvdXQoaW5kZXgsIGV4cGxvcmVkTGlzdCwgdGltZUxlbmd0aCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZXhwbG9yZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkgc2hvd1BhdGgoZW5kTm9kZSwgc2VsZik7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYm9hcmRBLnNob3VsZERpc2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2FyZEEuY2hhbmdlRnJvbVJlZCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsZ29Eb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZShleHBsb3JlZExpc3RbaW5kZXhdLCBpbmRleCwgZXhwbG9yZWRMaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB0aW1lb3V0KGluZGV4ICsgMSwgZXhwbG9yZWRMaXN0LCB0aW1lTGVuZ3RoKTtcbiAgICAgICAgfSwgdGltZUxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYW5nZShub2RlLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5pZCk7XG4gICAgICAgIGlmIChub2RlLnN0YXR1cyA9PT0gJ3VuZXhwbG9yZWQgd2VpZ2h0Jykge1xuICAgICAgICAgICAgbm9kZS5zdGF0dXMgPSAnZXhwbG9yZWQgd2VpZ2h0JztcbiAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gJ2V4cGxvcmVkIHdlaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zdGF0dXMgPT09ICd1bmV4cGxvcmVkJykge1xuICAgICAgICAgICAgbm9kZS5zdGF0dXMgPSAnZXhwbG9yZWQnO1xuICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSAnZXhwbG9yZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuc3RhdHVzID09PSAnc2hvcnRlc3RQYXRoIGV4cGxvcmVkIHdlaWdodCcpIHtcbiAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gJ3Nob3J0ZXN0UGF0aCBleHBsb3JlZCB3ZWlnaHQnO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LnN0YXR1cyA9PT0gJ3Nob3J0ZXN0UGF0aCcpIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUucGFyZW50LmlkKS5jbGFzc05hbWUgPSAnc2hvcnRlc3RQYXRoJztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkgc2VsZi5jaGFuZ2VGaW5hbENsYXNzTmFtZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuc3RhdHVzID09PSAnc2hvcnRlc3RQYXRoJykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LnN0YXR1cyAhPT0gJ3N0YXJ0Tm9kZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuc3RhdHVzID09PSAnc2hvcnRlc3RQYXRoJykgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5wYXJlbnQuaWQpLmNsYXNzTmFtZSA9ICdzaG9ydGVzdFBhdGgnO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q2xhc3NOYW1lID0gJ3Nob3J0ZXN0UGF0aCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRBbGdvcml0aG0gIT09ICdCRlMnICYmIHNlbGYuY3VycmVudEFsZ29yaXRobSAhPT0gJ0RGUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NsYXNzTmFtZSArPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NsYXNzTmFtZSArPSAnTk9ESVJFQ1RJT04nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ld0NsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUuaWQpLmNsYXNzTmFtZSA9IG5ld0NsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlLmlkKS5jbGFzc05hbWUgPSAnc2hvcnRlc3RQYXRoJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VGaW5hbENsYXNzTmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5wYXJlbnQuaWQpLmNsYXNzTmFtZSA9ICdzdGFydGluZ0NlbGwgc2hvcnRlc3RQYXRoJztcbiAgICAgICAgICAgICAgICBub2RlLnN0YXR1cyA9ICdzaG9ydGVzdFBhdGgnO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmZpbmFsTm9kZS5wYXJlbnQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5pZCkuY2xhc3NOYW1lID0gJ3Nob3J0ZXN0UGF0aCcgKyBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VGaW5hbENsYXNzTmFtZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvd1BhdGgobm9kZSwgc2VhcmNoKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIHZhciBsaXN0UGF0aCA9IFtdO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gc3RhcnROb2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zdGF0dXMgIT09IGVuZE5vZGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgbGlzdFBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kTm9kZS5zdGF0dXMgPT09IHNlbGYuZmluYWxOb2RlLnN0YXR1cykge1xuICAgICAgICAgICAgbGlzdFBhdGguZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RhdHVzID09PSAnZXhwbG9yZWQgd2VpZ2h0JyA/IGUuc3RhdHVzID0gJ3Nob3J0ZXN0UGF0aCBleHBsb3JlZCB3ZWlnaHQnIDogZS5zdGF0dXMgPSAnc2hvcnRlc3RQYXRoJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGltZW91dCgwLCBsaXN0UGF0aC5yZXZlcnNlKCksIDM1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuYm9hcmRBLnNob3VsZERpc2FibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aW1lb3V0KDAsIGV4cGxvcmVkTGlzdCwgMC4wMDEpO1xufTtcblxuU2VhcmNoLnByb3RvdHlwZS5hbGdvRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJvYXJkQS5hbGdvRG9uZSA9IHRydWU7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLmNoYW5nZUZpbmFsQ2xhc3NOYW1lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSkgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5pZCkuY2xhc3NOYW1lID0gJ3Nob3J0ZXN0UGF0aCc7XG4gICAgdmFyIGZpbmFsQ2VsbDtcbiAgICBmaW5hbENlbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmaW5hbENlbGwnKVsxXTtcbiAgICBpZiAoIWZpbmFsQ2VsbCkgZmluYWxDZWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZmluYWxDZWxsVVAnKVswXTtcbiAgICBpZiAoIWZpbmFsQ2VsbCkgZmluYWxDZWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZmluYWxDZWxsUklHSFQnKVswXTtcbiAgICBpZiAoIWZpbmFsQ2VsbCkgZmluYWxDZWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZmluYWxDZWxsRE9XTicpWzBdO1xuICAgIGlmICghZmluYWxDZWxsKSBmaW5hbENlbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmaW5hbENlbGxMRUZUJylbMF07XG4gICAgaWYgKHRoaXMuY3VycmVudEFsZ29yaXRobSAhPT0gJ0JGUycgJiYgdGhpcy5jdXJyZW50QWxnb3JpdGhtICE9PSAnREZTJykge1xuICAgICAgICBmaW5hbENlbGwuY2xhc3NOYW1lID0gJ2ZpbmFsQ2VsbCcgKyB0aGlzLmZpbmFsTm9kZS5kaXJlY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxDZWxsLmNsYXNzTmFtZSA9ICdmaW5hbENlbGwnICsgJ05PRElSRUNUSU9OJztcbiAgICB9XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLmNoYW5nZUZpcnN0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc3RhcnROb2RlLmlkKS5jbGFzc05hbWUgPSAnc3RhcnRpbmdDZWxsIHNob3J0ZXN0UGF0aCc7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnNob3dBbmltYXRpb25EcmFnID0gZnVuY3Rpb24gKGV4cGxvcmVkTGlzdCkge1xuICAgIGZvciAodmFyIGkgaW4gZXhwbG9yZWRMaXN0KSB7XG4gICAgICAgIHZhciBjZWxsID0gZXhwbG9yZWRMaXN0W2ldO1xuICAgICAgICBpZiAoY2VsbC5zdGF0dXMgPT09ICd1bmV4cGxvcmVkJykge1xuICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAnZXhwbG9yZWQnO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2VsbC5pZCkuY2xhc3NOYW1lID0gJ2V4cGxvcmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChjZWxsLnN0YXR1cyA9PT0gJ3VuZXhwbG9yZWQgd2VpZ2h0Jykge1xuICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAnZXhwbG9yZWQgd2VpZ2h0JztcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNlbGwuaWQpLmNsYXNzTmFtZSA9ICdleHBsb3JlZCB3ZWlnaHQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBlbmROb2RlID0gZXhwbG9yZWRMaXN0W2V4cGxvcmVkTGlzdC5sZW5ndGggLSAxXTtcbiAgICB2YXIgbmV3RW5kTm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIGVuZE5vZGUpO1xuICAgIHZhciBzaG9ydGVzdFBhdGhMaXN0ID0gW107XG4gICAgd2hpbGUgKGVuZE5vZGUgIT09IHRoaXMuc3RhcnROb2RlKSB7XG4gICAgICAgIHNob3J0ZXN0UGF0aExpc3QucHVzaChlbmROb2RlKTtcbiAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUucGFyZW50O1xuICAgIH1cbiAgICBzaG9ydGVzdFBhdGhMaXN0ID0gc2hvcnRlc3RQYXRoTGlzdC5yZXZlcnNlKCk7XG4gICAgaWYgKG5ld0VuZE5vZGUuc3RhdHVzID09PSAnZmluYWxOb2RlJykge1xuICAgICAgICB0aGlzLmNoYW5nZUZpcnN0Q2xhc3NOYW1lKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRmluYWxDbGFzc05hbWUoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzaG9ydGVzdFBhdGhMaXN0KSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHNob3J0ZXN0UGF0aExpc3RbaV07XG4gICAgICAgICAgICBpZiAoY2VsbC5zdGF0dXMgPT09ICdleHBsb3JlZCB3ZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAnc2hvcnRlc3RQYXRoIGV4cGxvcmVkIHdlaWdodCc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2VsbC5pZCkuY2xhc3NOYW1lID0gJ3Nob3J0ZXN0UGF0aCBleHBsb3JlZCB3ZWlnaHQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjZWxsLnN0YXR1cyAhPT0gJ3N0YXJ0Tm9kZScgJiYgY2VsbC5zdGF0dXMgIT09ICdmaW5hbE5vZGUnKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5zdGF0dXMgPSAnZXhwbG9yZWQnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNlbGwuaWQpLmNsYXNzTmFtZSA9ICdzaG9ydGVzdFBhdGgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm9hcmRBLnNob3VsZERpc2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmJvYXJkQS5jaGFuZ2VGcm9tUmVkKCk7XG4gICAgdGhpcy5ib2FyZEEuYWxnb0RvbmUgPSB0cnVlO1xufTtcblxuU2VhcmNoLnByb3RvdHlwZS5nZXROZWlnaGJvdXJzRGlqa3N0cmEgPSBmdW5jdGlvbiAoYXJyLCBub2RlLCBleHBsb3JlZExpc3QpIHtcbiAgICB2YXIgbmVpZ2JvdXJMaXN0ID0gW107XG4gICAgLy9VcFxuICAgIGlmIChub2RlLnkgPiAwICYmIGFycltub2RlLnkgLSAxXVtub2RlLnhdLnN0YXR1cyAhPT0gJ3dhbGwnICYmIHRoaXMuaGFzQmVlbkV4cGxvcmVkKGFycltub2RlLnkgLSAxXVtub2RlLnhdLCBleHBsb3JlZExpc3QpID09PSBmYWxzZSkge1xuICAgICAgICAvL0dldCBVcCBuZWlnaGJvdXJcbiAgICAgICAgdmFyIG5laWdoYm91ciA9IGFycltub2RlLnkgLSAxXVtub2RlLnhdO1xuICAgICAgICAvL0dldCBjdXJyZW50IGRpc3RhbmNlXG4gICAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBub2RlLmRpc3RhbmNlO1xuICAgICAgICAvL0dldCBNeSBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG15RGlyZWN0aW9uID0gbm9kZS5kaXJlY3Rpb247XG4gICAgICAgIC8vQ2FsY3VsYXRlIG51bWJlciBvZiBtb3ZlcyB0byBnZXQgdG8gR2V0IHRvIFVwIERpcmVjdGlvblxuICAgICAgICB2YXIgbnVtYmVyT2ZNb3ZlcyA9IHRoaXMuY2hlY2tOdW1iZXJPZk1vdmVzKG15RGlyZWN0aW9uLCAnVVAnKTtcbiAgICAgICAgLy9DYWxjdWxhdGUgbmV3IG5laWdoYm91ciBkaXN0YW5jZVxuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UgPSBjdXJyZW50RGlzdGFuY2UgKyBudW1iZXJPZk1vdmVzICsgMSArIG5laWdoYm91ci53ZWlnaHQ7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnVVAnO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vUmlnaHRcbiAgICBpZiAobm9kZS54IDwgYXJyWzBdLmxlbmd0aCAtIDEgJiYgYXJyW25vZGUueV1bbm9kZS54ICsgMV0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueV1bbm9kZS54ICsgMV0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueV1bbm9kZS54ICsgMV07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdSSUdIVCcpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IGN1cnJlbnREaXN0YW5jZSArIG51bWJlck9mTW92ZXMgKyAxICsgbmVpZ2hib3VyLndlaWdodDtcbiAgICAgICAgLy9JZiB0aGlzIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnREaXN0YW5jZSBvbiB0aGUgbmVpZ2hib3VyIGNoYW5nZVxuICAgICAgICBpZiAobmV3TmVpZ2hib3VyRGlzdGFuY2UgPCBuZWlnaGJvdXIuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXN0YW5jZSA9IG5ld05laWdoYm91ckRpc3RhbmNlO1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpcmVjdGlvbiA9ICdSSUdIVCc7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXIgdG8gbmVpZ2JvdXJMaXN0XG4gICAgICAgICAgICBuZWlnYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9Eb3duXG4gICAgaWYgKG5vZGUueSA8IGFyci5sZW5ndGggLSAxICYmIGFycltub2RlLnkgKyAxXVtub2RlLnhdLnN0YXR1cyAhPT0gJ3dhbGwnICYmIHRoaXMuaGFzQmVlbkV4cGxvcmVkKGFycltub2RlLnkgKyAxXVtub2RlLnhdLCBleHBsb3JlZExpc3QpID09PSBmYWxzZSkge1xuICAgICAgICAvL0dldCBVcCBuZWlnaGJvdXJcbiAgICAgICAgdmFyIG5laWdoYm91ciA9IGFycltub2RlLnkgKyAxXVtub2RlLnhdO1xuICAgICAgICAvL0dldCBjdXJyZW50IGRpc3RhbmNlXG4gICAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBub2RlLmRpc3RhbmNlO1xuICAgICAgICAvL0dldCBNeSBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG15RGlyZWN0aW9uID0gbm9kZS5kaXJlY3Rpb247XG4gICAgICAgIC8vQ2FsY3VsYXRlIG51bWJlciBvZiBtb3ZlcyB0byBnZXQgdG8gR2V0IHRvIFVwIERpcmVjdGlvblxuICAgICAgICB2YXIgbnVtYmVyT2ZNb3ZlcyA9IHRoaXMuY2hlY2tOdW1iZXJPZk1vdmVzKG15RGlyZWN0aW9uLCAnRE9XTicpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IGN1cnJlbnREaXN0YW5jZSArIG51bWJlck9mTW92ZXMgKyAxICsgbmVpZ2hib3VyLndlaWdodDtcbiAgICAgICAgLy9JZiB0aGlzIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnREaXN0YW5jZSBvbiB0aGUgbmVpZ2hib3VyIGNoYW5nZVxuICAgICAgICBpZiAobmV3TmVpZ2hib3VyRGlzdGFuY2UgPCBuZWlnaGJvdXIuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXN0YW5jZSA9IG5ld05laWdoYm91ckRpc3RhbmNlO1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpcmVjdGlvbiA9ICdET1dOJztcbiAgICAgICAgICAgIC8vQWRkIG5laWdoYm91ciB0byBuZWlnYm91ckxpc3RcbiAgICAgICAgICAgIG5laWdib3VyTGlzdC5wdXNoKG5laWdoYm91cik7XG4gICAgICAgICAgICBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL0xlZnRcbiAgICBpZiAobm9kZS54ID4gMCAmJiBhcnJbbm9kZS55XVtub2RlLnggLSAxXS5zdGF0dXMgIT09ICd3YWxsJyAmJiB0aGlzLmhhc0JlZW5FeHBsb3JlZChhcnJbbm9kZS55XVtub2RlLnggLSAxXSwgZXhwbG9yZWRMaXN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy9HZXQgVXAgbmVpZ2hib3VyXG4gICAgICAgIHZhciBuZWlnaGJvdXIgPSBhcnJbbm9kZS55XVtub2RlLnggLSAxXTtcbiAgICAgICAgLy9HZXQgY3VycmVudCBkaXN0YW5jZVxuICAgICAgICB2YXIgY3VycmVudERpc3RhbmNlID0gbm9kZS5kaXN0YW5jZTtcbiAgICAgICAgLy9HZXQgTXkgRGlyZWN0aW9uXG4gICAgICAgIHZhciBteURpcmVjdGlvbiA9IG5vZGUuZGlyZWN0aW9uO1xuICAgICAgICAvL0NhbGN1bGF0ZSBudW1iZXIgb2YgbW92ZXMgdG8gZ2V0IHRvIEdldCB0byBVcCBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG51bWJlck9mTW92ZXMgPSB0aGlzLmNoZWNrTnVtYmVyT2ZNb3ZlcyhteURpcmVjdGlvbiwgJ0xFRlQnKTtcbiAgICAgICAgLy9DYWxjdWxhdGUgbmV3IG5laWdoYm91ciBkaXN0YW5jZVxuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UgPSBjdXJyZW50RGlzdGFuY2UgKyBudW1iZXJPZk1vdmVzICsgMSArIG5laWdoYm91ci53ZWlnaHQ7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnTEVGVCc7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXIgdG8gbmVpZ2JvdXJMaXN0XG4gICAgICAgICAgICBuZWlnYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5laWdib3VyTGlzdDtcbn07XG5cblNlYXJjaC5wcm90b3R5cGUuZ2V0TmVpZ2hib3Vyc0FTdGFyID0gZnVuY3Rpb24gKGFyciwgbm9kZSwgZXhwbG9yZWRMaXN0LCBhbGdvLCBmaW5hbE5vZGUpIHtcbiAgICB2YXIgbmVpZ2JvdXJMaXN0ID0gW107XG4gICAgLy9VcFxuICAgIGlmIChub2RlLnkgPiAwICYmIGFycltub2RlLnkgLSAxXVtub2RlLnhdLnN0YXR1cyAhPT0gJ3dhbGwnICYmIHRoaXMuaGFzQmVlbkV4cGxvcmVkKGFycltub2RlLnkgLSAxXVtub2RlLnhdLCBleHBsb3JlZExpc3QpID09PSBmYWxzZSkge1xuICAgICAgICAvL0dldCBVcCBuZWlnaGJvdXJcbiAgICAgICAgdmFyIG5laWdoYm91ciA9IGFycltub2RlLnkgLSAxXVtub2RlLnhdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnbmVpZ2hib3VyJyxuZWlnaGJvdXIuZGlzdGFuY2UpXG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdVUCcpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IGN1cnJlbnREaXN0YW5jZSArIG51bWJlck9mTW92ZXMgKyAxICsgdGhpcy5tYW5oYXR0YW5EaXN0YW5jZShuZWlnaGJvdXIsIGZpbmFsTm9kZSkgKyBuZWlnaGJvdXIud2VpZ2h0O1xuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UyID0gY3VycmVudERpc3RhbmNlICsgbnVtYmVyT2ZNb3ZlcyArIDEgKyBNYXRoLnBvdyh0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgZmluYWxOb2RlKSwgNikgKyBuZWlnaGJvdXIud2VpZ2h0O1xuICAgICAgICBhbGdvID09PSAnMicgPyBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IG5ld05laWdoYm91ckRpc3RhbmNlMiA6IG5ld05laWdoYm91ckRpc3RhbmNlO1xuICAgICAgICAvL0lmIHRoaXMgaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudERpc3RhbmNlIG9uIHRoZSBuZWlnaGJvdXIgY2hhbmdlXG4gICAgICAgIGlmIChuZXdOZWlnaGJvdXJEaXN0YW5jZSA8IG5laWdoYm91ci5kaXN0YW5jZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJoZXJlXCIpXG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnVVAnO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vUmlnaHRcbiAgICBpZiAobm9kZS54IDwgYXJyWzBdLmxlbmd0aCAtIDEgJiYgYXJyW25vZGUueV1bbm9kZS54ICsgMV0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueV1bbm9kZS54ICsgMV0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueV1bbm9kZS54ICsgMV07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdSSUdIVCcpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IGN1cnJlbnREaXN0YW5jZSArIG51bWJlck9mTW92ZXMgKyAxICsgdGhpcy5tYW5oYXR0YW5EaXN0YW5jZShuZWlnaGJvdXIsIGZpbmFsTm9kZSkgKyBuZWlnaGJvdXIud2VpZ2h0O1xuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UyID0gY3VycmVudERpc3RhbmNlICsgbnVtYmVyT2ZNb3ZlcyArIDEgKyBNYXRoLnBvdyh0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgZmluYWxOb2RlKSwgNikgKyBuZWlnaGJvdXIud2VpZ2h0O1xuICAgICAgICBhbGdvID09PSAnMicgPyBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IG5ld05laWdoYm91ckRpc3RhbmNlMiA6IG5ld05laWdoYm91ckRpc3RhbmNlO1xuICAgICAgICAvL0lmIHRoaXMgaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudERpc3RhbmNlIG9uIHRoZSBuZWlnaGJvdXIgY2hhbmdlXG4gICAgICAgIGlmIChuZXdOZWlnaGJvdXJEaXN0YW5jZSA8IG5laWdoYm91ci5kaXN0YW5jZSkge1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpc3RhbmNlID0gbmV3TmVpZ2hib3VyRGlzdGFuY2U7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlyZWN0aW9uID0gJ1JJR0hUJztcbiAgICAgICAgICAgIC8vQWRkIG5laWdoYm91ciB0byBuZWlnYm91ckxpc3RcbiAgICAgICAgICAgIG5laWdib3VyTGlzdC5wdXNoKG5laWdoYm91cik7XG4gICAgICAgICAgICBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL0Rvd25cbiAgICBpZiAobm9kZS55IDwgYXJyLmxlbmd0aCAtIDEgJiYgYXJyW25vZGUueSArIDFdW25vZGUueF0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueSArIDFdW25vZGUueF0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueSArIDFdW25vZGUueF07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdET1dOJyk7XG4gICAgICAgIC8vQ2FsY3VsYXRlIG5ldyBuZWlnaGJvdXIgZGlzdGFuY2VcbiAgICAgICAgdmFyIG5ld05laWdoYm91ckRpc3RhbmNlID0gY3VycmVudERpc3RhbmNlICsgbnVtYmVyT2ZNb3ZlcyArIDEgKyB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgZmluYWxOb2RlKSArIG5laWdoYm91ci53ZWlnaHQ7XG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZTIgPSBjdXJyZW50RGlzdGFuY2UgKyBudW1iZXJPZk1vdmVzICsgMSArIE1hdGgucG93KHRoaXMubWFuaGF0dGFuRGlzdGFuY2UobmVpZ2hib3VyLCBmaW5hbE5vZGUpLCA2KSArIG5laWdoYm91ci53ZWlnaHQ7XG4gICAgICAgIGFsZ28gPT09ICcyJyA/IG5ld05laWdoYm91ckRpc3RhbmNlID0gbmV3TmVpZ2hib3VyRGlzdGFuY2UyIDogbmV3TmVpZ2hib3VyRGlzdGFuY2U7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnRE9XTic7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXIgdG8gbmVpZ2JvdXJMaXN0XG4gICAgICAgICAgICBuZWlnYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9MZWZ0XG4gICAgaWYgKG5vZGUueCA+IDAgJiYgYXJyW25vZGUueV1bbm9kZS54IC0gMV0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueV1bbm9kZS54IC0gMV0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueV1bbm9kZS54IC0gMV07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdMRUZUJyk7XG4gICAgICAgIC8vQ2FsY3VsYXRlIG5ldyBuZWlnaGJvdXIgZGlzdGFuY2VcbiAgICAgICAgdmFyIG5ld05laWdoYm91ckRpc3RhbmNlID0gY3VycmVudERpc3RhbmNlICsgbnVtYmVyT2ZNb3ZlcyArIDEgKyB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgZmluYWxOb2RlKSArIG5laWdoYm91ci53ZWlnaHQ7XG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZTIgPSBjdXJyZW50RGlzdGFuY2UgKyBudW1iZXJPZk1vdmVzICsgMSArIE1hdGgucG93KHRoaXMubWFuaGF0dGFuRGlzdGFuY2UobmVpZ2hib3VyLCBmaW5hbE5vZGUpLCA2KSArIG5laWdoYm91ci53ZWlnaHQ7XG4gICAgICAgIGFsZ28gPT09ICcyJyA/IG5ld05laWdoYm91ckRpc3RhbmNlID0gbmV3TmVpZ2hib3VyRGlzdGFuY2UyIDogbmV3TmVpZ2hib3VyRGlzdGFuY2U7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnTEVGVCc7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXIgdG8gbmVpZ2JvdXJMaXN0XG4gICAgICAgICAgICBuZWlnYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5laWdib3VyTGlzdDtcbn07XG5cblNlYXJjaC5wcm90b3R5cGUuZ2V0TmVpZ2hib3Vyc0dyZWVkeSA9IGZ1bmN0aW9uIChhcnIsIG5vZGUsIGV4cGxvcmVkTGlzdCkge1xuICAgIHZhciBuZWlnYm91ckxpc3QgPSBbXTtcbiAgICAvL1VwXG4gICAgaWYgKG5vZGUueSA+IDAgJiYgYXJyW25vZGUueSAtIDFdW25vZGUueF0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueSAtIDFdW25vZGUueF0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueSAtIDFdW25vZGUueF07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdVUCcpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IHRoaXMubWFuaGF0dGFuRGlzdGFuY2UobmVpZ2hib3VyLCB0aGlzLmZpbmFsTm9kZSk7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnVVAnO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vUmlnaHRcbiAgICBpZiAobm9kZS54IDwgYXJyWzBdLmxlbmd0aCAtIDEgJiYgYXJyW25vZGUueV1bbm9kZS54ICsgMV0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueV1bbm9kZS54ICsgMV0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueV1bbm9kZS54ICsgMV07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdSSUdIVCcpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IHRoaXMubWFuaGF0dGFuRGlzdGFuY2UobmVpZ2hib3VyLCB0aGlzLmZpbmFsTm9kZSk7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnUklHSFQnO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vRG93blxuICAgIGlmIChub2RlLnkgPCBhcnIubGVuZ3RoIC0gMSAmJiBhcnJbbm9kZS55ICsgMV1bbm9kZS54XS5zdGF0dXMgIT09ICd3YWxsJyAmJiB0aGlzLmhhc0JlZW5FeHBsb3JlZChhcnJbbm9kZS55ICsgMV1bbm9kZS54XSwgZXhwbG9yZWRMaXN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy9HZXQgVXAgbmVpZ2hib3VyXG4gICAgICAgIHZhciBuZWlnaGJvdXIgPSBhcnJbbm9kZS55ICsgMV1bbm9kZS54XTtcbiAgICAgICAgLy9HZXQgY3VycmVudCBkaXN0YW5jZVxuICAgICAgICB2YXIgY3VycmVudERpc3RhbmNlID0gbm9kZS5kaXN0YW5jZTtcbiAgICAgICAgLy9HZXQgTXkgRGlyZWN0aW9uXG4gICAgICAgIHZhciBteURpcmVjdGlvbiA9IG5vZGUuZGlyZWN0aW9uO1xuICAgICAgICAvL0NhbGN1bGF0ZSBudW1iZXIgb2YgbW92ZXMgdG8gZ2V0IHRvIEdldCB0byBVcCBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG51bWJlck9mTW92ZXMgPSB0aGlzLmNoZWNrTnVtYmVyT2ZNb3ZlcyhteURpcmVjdGlvbiwgJ0RPV04nKTtcbiAgICAgICAgLy9DYWxjdWxhdGUgbmV3IG5laWdoYm91ciBkaXN0YW5jZVxuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UgPSB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgdGhpcy5maW5hbE5vZGUpO1xuICAgICAgICAvL0lmIHRoaXMgaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudERpc3RhbmNlIG9uIHRoZSBuZWlnaGJvdXIgY2hhbmdlXG4gICAgICAgIGlmIChuZXdOZWlnaGJvdXJEaXN0YW5jZSA8IG5laWdoYm91ci5kaXN0YW5jZSkge1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpc3RhbmNlID0gbmV3TmVpZ2hib3VyRGlzdGFuY2U7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlyZWN0aW9uID0gJ0RPV04nO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vTGVmdFxuICAgIGlmIChub2RlLnggPiAwICYmIGFycltub2RlLnldW25vZGUueCAtIDFdLnN0YXR1cyAhPT0gJ3dhbGwnICYmIHRoaXMuaGFzQmVlbkV4cGxvcmVkKGFycltub2RlLnldW25vZGUueCAtIDFdLCBleHBsb3JlZExpc3QpID09PSBmYWxzZSkge1xuICAgICAgICAvL0dldCBVcCBuZWlnaGJvdXJcbiAgICAgICAgdmFyIG5laWdoYm91ciA9IGFycltub2RlLnldW25vZGUueCAtIDFdO1xuICAgICAgICAvL0dldCBjdXJyZW50IGRpc3RhbmNlXG4gICAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBub2RlLmRpc3RhbmNlO1xuICAgICAgICAvL0dldCBNeSBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG15RGlyZWN0aW9uID0gbm9kZS5kaXJlY3Rpb247XG4gICAgICAgIC8vQ2FsY3VsYXRlIG51bWJlciBvZiBtb3ZlcyB0byBnZXQgdG8gR2V0IHRvIFVwIERpcmVjdGlvblxuICAgICAgICB2YXIgbnVtYmVyT2ZNb3ZlcyA9IHRoaXMuY2hlY2tOdW1iZXJPZk1vdmVzKG15RGlyZWN0aW9uLCAnTEVGVCcpO1xuICAgICAgICAvL0NhbGN1bGF0ZSBuZXcgbmVpZ2hib3VyIGRpc3RhbmNlXG4gICAgICAgIHZhciBuZXdOZWlnaGJvdXJEaXN0YW5jZSA9IHRoaXMubWFuaGF0dGFuRGlzdGFuY2UobmVpZ2hib3VyLCB0aGlzLmZpbmFsTm9kZSk7XG4gICAgICAgIC8vSWYgdGhpcyBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50RGlzdGFuY2Ugb24gdGhlIG5laWdoYm91ciBjaGFuZ2VcbiAgICAgICAgaWYgKG5ld05laWdoYm91ckRpc3RhbmNlIDwgbmVpZ2hib3VyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlzdGFuY2UgPSBuZXdOZWlnaGJvdXJEaXN0YW5jZTtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXJlY3Rpb24gPSAnTEVGVCc7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXIgdG8gbmVpZ2JvdXJMaXN0XG4gICAgICAgICAgICBuZWlnYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5laWdib3VyTGlzdDtcbn07XG5cblNlYXJjaC5wcm90b3R5cGUuc2VhcmNoRGlqa3N0cmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGFydE5vZGUuZGlzdGFuY2UgPSAwO1xuICAgIHZhciBsaXN0VG9FeHBsb3JlID0gW3RoaXMuc3RhcnROb2RlXTtcbiAgICB2YXIgZXhwbG9yZWRMaXN0ID0gW107XG4gICAgdmFyIGlzUHJlc2VudCA9IGZ1bmN0aW9uIGlzUHJlc2VudChub2RlKSB7XG4gICAgICAgIHZhciByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBsb3JlZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChleHBsb3JlZExpc3RbaV0uaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgfTtcbiAgICB3aGlsZUxvb3A6IHdoaWxlIChsaXN0VG9FeHBsb3JlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvL1NvcnQgbGlzdFRvRXhwbG9yZSBieSBkaXN0YW5jZVxuICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zb3J0KGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5kaXN0YW5jZSAtIG5vZGVCLmRpc3RhbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9HZXQgY3VycmVudE5vZGVcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGlzdFRvRXhwbG9yZVswXTtcblxuICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMuZmluYWxOb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5zdGF0dXMgPSAnZmluYWxOb2RlJztcbiAgICAgICAgICAgIGV4cGxvcmVkTGlzdC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGJyZWFrIHdoaWxlTG9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE5vZGUuc3RhdHVzID09PSAnd2FsbCcpIHtcbiAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1ByZXNlbnQoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAvL0lmIGN1cnJlbnROb2RlIGlzIGZpbmFsTm9kZSBicmVha1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmZpbmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrIHdoaWxlTG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vR2V0IGN1cnJlbnROb2RlJ3MgbmVpZ2hib3Vyc1xuICAgICAgICAgICAgdmFyIG5laWdoYm91cnMgPSB0aGlzLmdldE5laWdoYm91cnNEaWprc3RyYSh0aGlzLmJvYXJkLCBjdXJyZW50Tm9kZSwgZXhwbG9yZWRMaXN0KTtcbiAgICAgICAgICAgIC8vQWRkIG5laWdoYm91cnMgdG8gbGlzdFRvRXhwbG9yZVxuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuY29uY2F0KG5laWdoYm91cnMpO1xuICAgICAgICAgICAgLy9SZW1vdmUgY3VycmVudE5vZGUgZnJvbSBsaXN0VG9FeHBsb3JlXG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vQWRkIGN1cnJlbnROb2RlIHRvIGV4cGxvcmVkTGlzdFxuICAgICAgICAgICAgZXhwbG9yZWRMaXN0LnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ib2FyZEEuY3VycmVudEFsZ28gPSAnRGlqa3N0cmEnO1xuXG4gICAgcmV0dXJuIGV4cGxvcmVkTGlzdDtcbn07XG5cblNlYXJjaC5wcm90b3R5cGUuaGFzQmVlbkV4cGxvcmVkID0gZnVuY3Rpb24gKG5vZGUsIGV4cGxvcmVkTGlzdCkge1xuICAgIHZhciByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpIGluIGV4cGxvcmVkTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGV4cGxvcmVkTGlzdFtpXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsO1xufTtcblxuU2VhcmNoLnByb3RvdHlwZS5jaGVja051bWJlck9mTW92ZXMgPSBmdW5jdGlvbiAoY3VycmVudERpcmVjdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGN1cnJlbnREaXJlY3Rpb24gPT09IGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKChjdXJyZW50RGlyZWN0aW9uID09PSAnVVAnIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09ICdET1dOJykgJiYgKGRpcmVjdGlvbiA9PT0gJ0xFRlQnIHx8IGRpcmVjdGlvbiA9PT0gJ1JJR0hUJykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICgoY3VycmVudERpcmVjdGlvbiA9PT0gJ0xFRlQnIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09ICdSSUdIVCcpICYmIChkaXJlY3Rpb24gPT09ICdVUCcgfHwgZGlyZWN0aW9uID09PSAnRE9XTicpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoKGN1cnJlbnREaXJlY3Rpb24gPT09ICdMRUZUJyB8fCBjdXJyZW50RGlyZWN0aW9uID09PSAnUklHSFQnKSAmJiAoZGlyZWN0aW9uID09PSAnTEVGVCcgfHwgZGlyZWN0aW9uID09PSAnUklHSFQnKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2UgaWYgKChjdXJyZW50RGlyZWN0aW9uID09PSAnVVAnIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09ICdET1dOJykgJiYgKGRpcmVjdGlvbiA9PT0gJ1VQJyB8fCBkaXJlY3Rpb24gPT09ICdET1dOJykpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxufTtcblxuU2VhcmNoLnByb3RvdHlwZS5tYW5oYXR0YW5EaXN0YW5jZSA9IGZ1bmN0aW9uIChub2RlMSwgbm9kZTIpIHtcbiAgICB2YXIgeERpZmYgPSBNYXRoLmFicyhub2RlMS54IC0gbm9kZTIueCk7XG4gICAgdmFyIHlEaWZmID0gTWF0aC5hYnMobm9kZTEueSAtIG5vZGUyLnkpO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4RGlmZiwgMikgKyBNYXRoLnBvdyh5RGlmZiwgMikpO1xuICAgIHZhciBzdW0gPSB4RGlmZiArIHlEaWZmO1xuICAgIHJldHVybiBzdW07XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLnJlYWxBU3RhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YXJ0Tm9kZS5kaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5zdGFydE5vZGUuaGV1cmlzdGljRGlzdGFuY2UgPSB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKHRoaXMuc3RhcnROb2RlLCB0aGlzLmZpbmFsTm9kZSk7XG4gICAgdGhpcy5zdGFydE5vZGUudG90YWxEaXN0YW5jZSA9IHRoaXMuc3RhcnROb2RlLmRpc3RhbmNlICsgdGhpcy5zdGFydE5vZGUuaGV1cmlzdGljRGlzdGFuY2U7XG4gICAgdmFyIGxpc3RUb0V4cGxvcmUgPSBbdGhpcy5zdGFydE5vZGVdO1xuICAgIHZhciBleHBsb3JlZExpc3QgPSBbXTtcbiAgICB2YXIgaXNQcmVzZW50ID0gZnVuY3Rpb24gaXNQcmVzZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGxvcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cGxvcmVkTGlzdFtpXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9O1xuICAgIHdoaWxlTG9vcDogd2hpbGUgKGxpc3RUb0V4cGxvcmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vU29ydCBsaXN0VG9FeHBsb3JlIGJ5IGRpc3RhbmNlXG4gICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNvcnQoZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVBLnRvdGFsRGlzdGFuY2UgKyBub2RlQS5oZXVyaXN0aWNEaXN0YW5jZSAtIChub2RlQi50b3RhbERpc3RhbmNlICsgbm9kZUIuaGV1cmlzdGljRGlzdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9HZXQgY3VycmVudE5vZGVcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGlzdFRvRXhwbG9yZVswXTtcblxuICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMuZmluYWxOb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5zdGF0dXMgPSAnZmluYWxOb2RlJztcbiAgICAgICAgICAgIGV4cGxvcmVkTGlzdC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGJyZWFrIHdoaWxlTG9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE5vZGUuc3RhdHVzID09PSAnd2FsbCcpIHtcbiAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1ByZXNlbnQoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAvL0lmIGN1cnJlbnROb2RlIGlzIGZpbmFsTm9kZSBicmVha1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmZpbmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrIHdoaWxlTG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vR2V0IGN1cnJlbnROb2RlJ3MgbmVpZ2hib3Vyc1xuICAgICAgICAgICAgdmFyIG5laWdoYm91cnMgPSB0aGlzLmdldE5laWdoYm91cnNSZWFsQVN0YXIodGhpcy5ib2FyZCwgY3VycmVudE5vZGUsIGV4cGxvcmVkTGlzdCk7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXJzIHRvIGxpc3RUb0V4cGxvcmVcbiAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLmNvbmNhdChuZWlnaGJvdXJzKTtcbiAgICAgICAgICAgIC8vUmVtb3ZlIGN1cnJlbnROb2RlIGZyb20gbGlzdFRvRXhwbG9yZVxuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgICAgICAvL0FkZCBjdXJyZW50Tm9kZSB0byBleHBsb3JlZExpc3RcbiAgICAgICAgICAgIGV4cGxvcmVkTGlzdC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm9hcmRBLmN1cnJlbnRBbGdvID0gJ1JlYWxBU3Rhcic7XG4gICAgcmV0dXJuIGV4cGxvcmVkTGlzdDtcbn07XG5cblNlYXJjaC5wcm90b3R5cGUuZ2V0TmVpZ2hib3Vyc1JlYWxBU3RhciA9IGZ1bmN0aW9uIChhcnIsIG5vZGUsIGV4cGxvcmVkTGlzdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGlzdCA9IHRoaXMuZ2V0TmVpZ2hib3Vyc0RpamtzdHJhKGFyciwgbm9kZSwgZXhwbG9yZWRMaXN0KTtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm91cikge1xuICAgICAgICBuZWlnaGJvdXIuaGV1cmlzdGljRGlzdGFuY2UgPSBzZWxmLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgc2VsZi5maW5hbE5vZGUpO1xuICAgICAgICBuZWlnaGJvdXIudG90YWxEaXN0YW5jZSA9IG5laWdoYm91ci5kaXN0YW5jZSArIG5laWdoYm91ci5oZXVyaXN0aWNEaXN0YW5jZTtcbiAgICAgICAgY29uc29sZS5sb2cobmVpZ2hib3VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cblNlYXJjaC5wcm90b3R5cGUuc2VhcmNoUmVhbEFTdGFhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YXJ0Tm9kZS5kaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5zdGFydE5vZGUuaGV1cmlzdGljRGlzdGFuY2UgPSB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKHRoaXMuc3RhcnROb2RlLCB0aGlzLmZpbmFsTm9kZSk7XG4gICAgdGhpcy5zdGFydE5vZGUudG90YWxEaXN0YW5jZSA9IHRoaXMuc3RhcnROb2RlLmRpc3RhbmNlICsgdGhpcy5zdGFydE5vZGUuaGV1cmlzdGljRGlzdGFuY2U7XG4gICAgdmFyIGxpc3RUb0V4cGxvcmUgPSBbdGhpcy5zdGFydE5vZGVdO1xuICAgIHZhciBleHBsb3JlZExpc3QgPSBbXTtcbiAgICB2YXIgaXNQcmVzZW50ID0gZnVuY3Rpb24gaXNQcmVzZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGxvcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cGxvcmVkTGlzdFtpXS5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9O1xuICAgIHdoaWxlTG9vcDogd2hpbGUgKGxpc3RUb0V4cGxvcmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vU29ydCBsaXN0VG9FeHBsb3JlIGJ5IGRpc3RhbmNlXG4gICAgICAgIGxpc3RUb0V4cGxvcmUgPSBsaXN0VG9FeHBsb3JlLnNvcnQoZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgaWYgKG5vZGVBLnRvdGFsRGlzdGFuY2UgPT09IG5vZGVCLnRvdGFsRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUEuaGV1cmlzdGljRGlzdGFuY2UgLSBub2RlQi5oZXVyaXN0aWNEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlQS50b3RhbERpc3RhbmNlIC0gbm9kZUIudG90YWxEaXN0YW5jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vR2V0IGN1cnJlbnROb2RlXG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGxpc3RUb0V4cGxvcmVbMF07XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmZpbmFsTm9kZSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc3RhdHVzID0gJ2ZpbmFsTm9kZSc7XG4gICAgICAgICAgICBleHBsb3JlZExpc3QucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBicmVhayB3aGlsZUxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnN0YXR1cyA9PT0gJ3dhbGwnKSB7XG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNQcmVzZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgLy9JZiBjdXJyZW50Tm9kZSBpcyBmaW5hbE5vZGUgYnJlYWtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGhpcy5maW5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVhayB3aGlsZUxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0dldCBjdXJyZW50Tm9kZSdzIG5laWdoYm91cnNcbiAgICAgICAgICAgIHZhciBuZWlnaGJvdXJzID0gdGhpcy5nZXROZWlnaGJvdXJzUmVhbEFTdGFhcih0aGlzLmJvYXJkLCBjdXJyZW50Tm9kZSwgZXhwbG9yZWRMaXN0KTtcbiAgICAgICAgICAgIC8vQWRkIG5laWdoYm91cnMgdG8gbGlzdFRvRXhwbG9yZVxuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuY29uY2F0KG5laWdoYm91cnMpO1xuICAgICAgICAgICAgLy9SZW1vdmUgY3VycmVudE5vZGUgZnJvbSBsaXN0VG9FeHBsb3JlXG4gICAgICAgICAgICBsaXN0VG9FeHBsb3JlID0gbGlzdFRvRXhwbG9yZS5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vQWRkIGN1cnJlbnROb2RlIHRvIGV4cGxvcmVkTGlzdFxuICAgICAgICAgICAgZXhwbG9yZWRMaXN0LnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZSA9IGxpc3RUb0V4cGxvcmUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ib2FyZEEuY3VycmVudEFsZ28gPSAnUmVhbEFTdGFyJztcblxuICAgIHJldHVybiBleHBsb3JlZExpc3Q7XG59O1xuXG5TZWFyY2gucHJvdG90eXBlLmdldE5laWdoYm91cnNSZWFsQVN0YWFyID0gZnVuY3Rpb24gKGFyciwgbm9kZSwgZXhwbG9yZWRMaXN0KSB7XG4gICAgdmFyIG5laWdib3VyTGlzdCA9IFtdO1xuICAgIC8vVXBcbiAgICBpZiAobm9kZS55ID4gMCAmJiBhcnJbbm9kZS55IC0gMV1bbm9kZS54XS5zdGF0dXMgIT09ICd3YWxsJyAmJiB0aGlzLmhhc0JlZW5FeHBsb3JlZChhcnJbbm9kZS55IC0gMV1bbm9kZS54XSwgZXhwbG9yZWRMaXN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy9HZXQgVXAgbmVpZ2hib3VyXG4gICAgICAgIHZhciBuZWlnaGJvdXIgPSBhcnJbbm9kZS55IC0gMV1bbm9kZS54XTtcbiAgICAgICAgLy9HZXQgY3VycmVudCBkaXN0YW5jZVxuICAgICAgICB2YXIgY3VycmVudERpc3RhbmNlID0gbm9kZS5kaXN0YW5jZTtcbiAgICAgICAgLy9HZXQgTXkgRGlyZWN0aW9uXG4gICAgICAgIHZhciBteURpcmVjdGlvbiA9IG5vZGUuZGlyZWN0aW9uO1xuICAgICAgICAvL0NhbGN1bGF0ZSBudW1iZXIgb2YgbW92ZXMgdG8gZ2V0IHRvIEdldCB0byBVcCBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG51bWJlck9mTW92ZXMgPSB0aGlzLmNoZWNrTnVtYmVyT2ZNb3ZlcyhteURpcmVjdGlvbiwgJ1VQJyk7XG4gICAgICAgIC8vQ2FsY3VsYXRlIG5ldyBuZWlnaGJvdXIgZGlzdGFuY2VcbiAgICAgICAgdmFyIG5ld05laWdoYm91ckRpc3RhbmNlID0gbm9kZS5kaXN0YW5jZSArIDEgKyBudW1iZXJPZk1vdmVzICsgbmVpZ2hib3VyLndlaWdodDtcbiAgICAgICAgbmVpZ2hib3VyLmhldXJpc3RpY0Rpc3RhbmNlID0gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZShuZWlnaGJvdXIsIHRoaXMuZmluYWxOb2RlKTtcbiAgICAgICAgLy9JZiB0aGlzIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnREaXN0YW5jZSBvbiB0aGUgbmVpZ2hib3VyIGNoYW5nZVxuICAgICAgICBpZiAobmV3TmVpZ2hib3VyRGlzdGFuY2UgPCBuZWlnaGJvdXIuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXN0YW5jZSA9IG5ld05laWdoYm91ckRpc3RhbmNlO1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpcmVjdGlvbiA9ICdVUCc7XG4gICAgICAgICAgICBuZWlnaGJvdXIudG90YWxEaXN0YW5jZSA9IG5laWdoYm91ci5oZXVyaXN0aWNEaXN0YW5jZSArIG5laWdoYm91ci5kaXN0YW5jZTtcbiAgICAgICAgICAgIC8vQWRkIG5laWdoYm91ciB0byBuZWlnYm91ckxpc3RcbiAgICAgICAgICAgIG5laWdib3VyTGlzdC5wdXNoKG5laWdoYm91cik7XG4gICAgICAgICAgICBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL1JpZ2h0XG4gICAgaWYgKG5vZGUueCA8IGFyclswXS5sZW5ndGggLSAxICYmIGFycltub2RlLnldW25vZGUueCArIDFdLnN0YXR1cyAhPT0gJ3dhbGwnICYmIHRoaXMuaGFzQmVlbkV4cGxvcmVkKGFycltub2RlLnldW25vZGUueCArIDFdLCBleHBsb3JlZExpc3QpID09PSBmYWxzZSkge1xuICAgICAgICAvL0dldCBVcCBuZWlnaGJvdXJcbiAgICAgICAgdmFyIG5laWdoYm91ciA9IGFycltub2RlLnldW25vZGUueCArIDFdO1xuICAgICAgICAvL0dldCBjdXJyZW50IGRpc3RhbmNlXG4gICAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBub2RlLmRpc3RhbmNlO1xuICAgICAgICAvL0dldCBNeSBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG15RGlyZWN0aW9uID0gbm9kZS5kaXJlY3Rpb247XG4gICAgICAgIC8vQ2FsY3VsYXRlIG51bWJlciBvZiBtb3ZlcyB0byBnZXQgdG8gR2V0IHRvIFVwIERpcmVjdGlvblxuICAgICAgICB2YXIgbnVtYmVyT2ZNb3ZlcyA9IHRoaXMuY2hlY2tOdW1iZXJPZk1vdmVzKG15RGlyZWN0aW9uLCAnUklHSFQnKTtcbiAgICAgICAgLy9DYWxjdWxhdGUgbmV3IG5laWdoYm91ciBkaXN0YW5jZVxuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UgPSBub2RlLmRpc3RhbmNlICsgMSArIG51bWJlck9mTW92ZXMgKyBuZWlnaGJvdXIud2VpZ2h0O1xuICAgICAgICBuZWlnaGJvdXIuaGV1cmlzdGljRGlzdGFuY2UgPSB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgdGhpcy5maW5hbE5vZGUpO1xuICAgICAgICAvL0lmIHRoaXMgaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudERpc3RhbmNlIG9uIHRoZSBuZWlnaGJvdXIgY2hhbmdlXG4gICAgICAgIGlmIChuZXdOZWlnaGJvdXJEaXN0YW5jZSA8IG5laWdoYm91ci5kaXN0YW5jZSkge1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpc3RhbmNlID0gbmV3TmVpZ2hib3VyRGlzdGFuY2U7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlyZWN0aW9uID0gJ1JJR0hUJztcbiAgICAgICAgICAgIG5laWdoYm91ci50b3RhbERpc3RhbmNlID0gbmVpZ2hib3VyLmhldXJpc3RpY0Rpc3RhbmNlICsgbmVpZ2hib3VyLmRpc3RhbmNlO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vRG93blxuICAgIGlmIChub2RlLnkgPCBhcnIubGVuZ3RoIC0gMSAmJiBhcnJbbm9kZS55ICsgMV1bbm9kZS54XS5zdGF0dXMgIT09ICd3YWxsJyAmJiB0aGlzLmhhc0JlZW5FeHBsb3JlZChhcnJbbm9kZS55ICsgMV1bbm9kZS54XSwgZXhwbG9yZWRMaXN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy9HZXQgVXAgbmVpZ2hib3VyXG4gICAgICAgIHZhciBuZWlnaGJvdXIgPSBhcnJbbm9kZS55ICsgMV1bbm9kZS54XTtcbiAgICAgICAgLy9HZXQgY3VycmVudCBkaXN0YW5jZVxuICAgICAgICB2YXIgY3VycmVudERpc3RhbmNlID0gbm9kZS5kaXN0YW5jZTtcbiAgICAgICAgLy9HZXQgTXkgRGlyZWN0aW9uXG4gICAgICAgIHZhciBteURpcmVjdGlvbiA9IG5vZGUuZGlyZWN0aW9uO1xuICAgICAgICAvL0NhbGN1bGF0ZSBudW1iZXIgb2YgbW92ZXMgdG8gZ2V0IHRvIEdldCB0byBVcCBEaXJlY3Rpb25cbiAgICAgICAgdmFyIG51bWJlck9mTW92ZXMgPSB0aGlzLmNoZWNrTnVtYmVyT2ZNb3ZlcyhteURpcmVjdGlvbiwgJ0RPV04nKTtcbiAgICAgICAgLy9DYWxjdWxhdGUgbmV3IG5laWdoYm91ciBkaXN0YW5jZVxuICAgICAgICB2YXIgbmV3TmVpZ2hib3VyRGlzdGFuY2UgPSBub2RlLmRpc3RhbmNlICsgMSArIG51bWJlck9mTW92ZXMgKyBuZWlnaGJvdXIud2VpZ2h0O1xuICAgICAgICBuZWlnaGJvdXIuaGV1cmlzdGljRGlzdGFuY2UgPSB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlKG5laWdoYm91ciwgdGhpcy5maW5hbE5vZGUpO1xuICAgICAgICAvL0lmIHRoaXMgaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudERpc3RhbmNlIG9uIHRoZSBuZWlnaGJvdXIgY2hhbmdlXG4gICAgICAgIGlmIChuZXdOZWlnaGJvdXJEaXN0YW5jZSA8IG5laWdoYm91ci5kaXN0YW5jZSkge1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpc3RhbmNlID0gbmV3TmVpZ2hib3VyRGlzdGFuY2U7XG4gICAgICAgICAgICBuZWlnaGJvdXIuZGlyZWN0aW9uID0gJ0RPV04nO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnRvdGFsRGlzdGFuY2UgPSBuZWlnaGJvdXIuaGV1cmlzdGljRGlzdGFuY2UgKyBuZWlnaGJvdXIuZGlzdGFuY2U7XG4gICAgICAgICAgICAvL0FkZCBuZWlnaGJvdXIgdG8gbmVpZ2JvdXJMaXN0XG4gICAgICAgICAgICBuZWlnYm91ckxpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgICAgbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9MZWZ0XG4gICAgaWYgKG5vZGUueCA+IDAgJiYgYXJyW25vZGUueV1bbm9kZS54IC0gMV0uc3RhdHVzICE9PSAnd2FsbCcgJiYgdGhpcy5oYXNCZWVuRXhwbG9yZWQoYXJyW25vZGUueV1bbm9kZS54IC0gMV0sIGV4cGxvcmVkTGlzdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vR2V0IFVwIG5laWdoYm91clxuICAgICAgICB2YXIgbmVpZ2hib3VyID0gYXJyW25vZGUueV1bbm9kZS54IC0gMV07XG4gICAgICAgIC8vR2V0IGN1cnJlbnQgZGlzdGFuY2VcbiAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IG5vZGUuZGlzdGFuY2U7XG4gICAgICAgIC8vR2V0IE15IERpcmVjdGlvblxuICAgICAgICB2YXIgbXlEaXJlY3Rpb24gPSBub2RlLmRpcmVjdGlvbjtcbiAgICAgICAgLy9DYWxjdWxhdGUgbnVtYmVyIG9mIG1vdmVzIHRvIGdldCB0byBHZXQgdG8gVXAgRGlyZWN0aW9uXG4gICAgICAgIHZhciBudW1iZXJPZk1vdmVzID0gdGhpcy5jaGVja051bWJlck9mTW92ZXMobXlEaXJlY3Rpb24sICdMRUZUJyk7XG4gICAgICAgIC8vQ2FsY3VsYXRlIG5ldyBuZWlnaGJvdXIgZGlzdGFuY2VcbiAgICAgICAgdmFyIG5ld05laWdoYm91ckRpc3RhbmNlID0gbm9kZS5kaXN0YW5jZSArIDEgKyBudW1iZXJPZk1vdmVzICsgbmVpZ2hib3VyLndlaWdodDtcbiAgICAgICAgbmVpZ2hib3VyLmhldXJpc3RpY0Rpc3RhbmNlID0gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZShuZWlnaGJvdXIsIHRoaXMuZmluYWxOb2RlKTtcbiAgICAgICAgLy9JZiB0aGlzIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnREaXN0YW5jZSBvbiB0aGUgbmVpZ2hib3VyIGNoYW5nZVxuICAgICAgICBpZiAobmV3TmVpZ2hib3VyRGlzdGFuY2UgPCBuZWlnaGJvdXIuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG5laWdoYm91ci5kaXN0YW5jZSA9IG5ld05laWdoYm91ckRpc3RhbmNlO1xuICAgICAgICAgICAgbmVpZ2hib3VyLmRpcmVjdGlvbiA9ICdMRUZUJztcbiAgICAgICAgICAgIG5laWdoYm91ci50b3RhbERpc3RhbmNlID0gbmVpZ2hib3VyLmhldXJpc3RpY0Rpc3RhbmNlICsgbmVpZ2hib3VyLmRpc3RhbmNlO1xuICAgICAgICAgICAgLy9BZGQgbmVpZ2hib3VyIHRvIG5laWdib3VyTGlzdFxuICAgICAgICAgICAgbmVpZ2JvdXJMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICAgIG5laWdoYm91ci5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWlnYm91ckxpc3Q7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTZWFyY2g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvU2VhcmNoLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(g,I,n){g.exports=n(0)}]);